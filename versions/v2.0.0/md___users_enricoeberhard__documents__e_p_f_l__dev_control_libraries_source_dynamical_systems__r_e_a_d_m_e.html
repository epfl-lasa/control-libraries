<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Control Libraries: dynamical_systems</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Control Libraries
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespacedynamical__systems.html">dynamical_systems</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This library provides a set of classes to represent <b>Dynamical Systems</b>: functions which map a state to a state derivative. Those are a set of helpers functions to handle common concepts in robotics such as transformations between frames and the link between them and the robot state. This description covers most of the functionalities starting from the spatial transformations.</p>
<h2>Table of contents:</h2>
<ul>
<li><a href="#base-dynamicalsystem">Base DynamicalSystem</a><ul>
<li><a href="#base-frame">Base frame</a></li>
</ul>
</li>
<li><a href="#linear">Linear</a><ul>
<li><a href="#configuring-the-linear-ds">Configuring the Linear DS</a></li>
<li><a href="#evaluating-the-linear-ds">Evaluating the Linear DS</a></li>
<li><a href="#reference-frames">Reference frames</a></li>
</ul>
</li>
<li><a href="#circular">Circular</a><ul>
<li><a href="#configuring-the-circular-ds">Configuring the Circular DS</a></li>
</ul>
</li>
<li><a href="#ring">Ring</a><ul>
<li><a href="#configuring-the-ring-ds">Configuring the Ring DS</a></li>
</ul>
</li>
</ul>
<h2>Base DynamicalSystem</h2>
<p>The base class DynamicalSystem defines the main public interface pattern which the derived classes follow.</p>
<p>It is templated for any state type, though the intention is to use the <b>State Representation</b> library (for example, <code>CartesianState</code> or <code>JointState</code>).</p>
<p>The main function is: </p><div class="fragment"><div class="line">{c++}</div><div class="line">template&lt;class S&gt;</div><div class="line">S DynamicalSystem&lt;S&gt;::evaluate(const S&amp; state) const</div></div><!-- fragment --><p> where <code>S</code> is the state representation type. The purpose of the evaluate function is to calculate a state derivative from a state. The current implementations support calculating a velocity from a position in either joint space or Cartesian space, though higher derivatives and other space types can be extended in a similar fashion.</p>
<p>In the case of a <code>CartesianState</code>, only the position and orientation is evaluated, and the returned object updates only the linear and angular velocity properties. In the case of <code>JointState</code>, only the joint position is evaluated, and the returned object contains only the joint velocity.</p>
<h3>Base frame</h3>
<p>The <b>DynamicalSystem</b> base class has a private <code>base_frame</code> property, which can be thought of as the DS origin. The functions <code>get_base_frame()</code> and <code>set_base_frame(const S&amp; state)</code> can be used to access or modify this base frame.</p>
<p>The DynamicalSystem can be constructed with a <code>state</code> to set the base frame, or with string frame name. In the latter case the base frame is set as a null / Identity frame with the specified name. For example, <code>DynamicalSystem&lt;CartesianState&gt;("base")</code> will create a dynamical system with the null base frame "base", expressed in its own frame "base".</p>
<p>In most cases, the constructor for the base DynamicalSystem should not be used directly, and rather the derived DS classes should construct the base accordingly.</p>
<p>However, the <code>set_base_frame()</code> method remains useful in combination with derived classes. See the section on <a href="#reference-frames">Linear DS reference frames</a> for examples.</p>
<h2>Linear</h2>
<p>The <b>Linear</b> DS can be thought of as a point attractor, with a velocity that is linearly proportional to the distance of the current state from the attractor. It is currently implemented for the <code>CartesianState</code> and <code>JointState</code> types.</p>
<p>The Linear DS is constructed with a state as an argument; this becomes the attractor. </p><div class="fragment"><div class="line">{c++}</div><div class="line">state_representation::CartesianState cartesianAttractor(&quot;A&quot;);</div><div class="line">dynamical_systems::Linear&lt;state_representation::CartesianState&gt; linear(cartesianAttractor);</div><div class="line"></div><div class="line">state_representation::JointState jointAttractor(&quot;B&quot;);</div><div class="line">dynamical_systems::Linear&lt;state_representation::JointState&gt; linear(jointAttractor);</div></div><!-- fragment --><h3>Configuring the Linear DS</h3>
<p>The Linear DS has the following core parameters:</p><ul>
<li><b>attractor</b>; the <code>CartesianState</code> or <code>JointState</code> type object defining the attractor pose relative to the DS base frame</li>
<li><b>gain</b>; the proportional gain acting towards the attractor</li>
</ul>
<p>Each parameter has corresponding <code>set_</code> and <code>get_</code> functions.</p>
<p>To change the strength of the attractor, a gain can be passed as the second argument during construction or passed to the <code>set_gain()</code> member function. The gain defines the proportionality between a distance unit and a velocity unit, and is internally stored as a square matrix with a size corresponding to the degrees of freedom in the state representation. For example, the <code>CartesianState</code> has six degrees of freedom (XYZ in linear and angular space), while the <code>JointState</code> would have as many degrees of freedom as joints. The gain can be defined as a matrix directly, as a diagonal vector of the appropriate length, or as a scalar (which sets the value along the diagonal elements of the matrix). </p><div class="fragment"><div class="line">{c++}</div><div class="line">// set a gain (scalar, vector or matrix during construction)</div><div class="line">double gain = 10;</div><div class="line">state_representation::CartesianState csA(&quot;A&quot;);</div><div class="line">dynamical_systems::Linear&lt;state_representation::CartesianState&gt; linear(csA, gain);</div><div class="line"></div><div class="line">// or set / update the gain for the created object</div><div class="line">std::vector&lt;double&gt; gains = {1, 2, 3, 4, 5, 6};</div><div class="line">linear.set_gain(gains);</div><div class="line"></div><div class="line">// update the attractor</div><div class="line">state_representation::CartesianState csB(&quot;B&quot;);</div><div class="line">linear.set_attractor(csB);</div></div><!-- fragment --><h3>Evaluating the Linear DS</h3>
<p>To get the velocity from a state, simply call the <code>evaluate()</code> function.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">state_representation::CartesianState csA(&quot;A&quot;), csB(&quot;B&quot;);</div><div class="line">dynamical_systems::Linear&lt;state_representation::CartesianState&gt; linear(csA);</div><div class="line"></div><div class="line">// note: the return type of evaluate() is a CartesianState, but</div><div class="line">// it can be directly assigned to a CartesianTwist because the =operator</div><div class="line">// has been defined for that purpose</div><div class="line">state_representation::CartesianTwist twist = linear.evaluate(csB);</div></div><!-- fragment --><p>The returned velocity will always be expressed in the same reference frame as the input state.</p>
<h3>Reference frames</h3>
<p>The following section applies for the <code>CartesianState</code> type.</p>
<p>The <code>evaulate()</code> function will always return a twist expressed in the same reference frame as the input state, provided that the input state is compatible with the DS.</p>
<p>The input state must be expressed in one of two supported reference frames:</p><ol type="1">
<li>The reference frame of the input is the DS base frame</li>
<li>The reference frame of the input matches the reference frame of the DS base frame</li>
</ol>
<p>The following snippet illustrates the difference in these two options. </p><div class="fragment"><div class="line">{c++}</div><div class="line">// create a linear DS with attractor B in frame A</div><div class="line">state_representation::CartesianState BinA(&quot;B&quot;, &quot;A&quot;);</div><div class="line">dynamical_systems::Linear&lt;state_representation::CartesianState&gt; linearDS(BinA);</div><div class="line"></div><div class="line">linearDS.get_attractor().get_name();             // &quot;B&quot;</div><div class="line">linearDS.get_attractor().get_reference_frame();  // &quot;A&quot;</div><div class="line">linearDS.get_base_frame().get_name();            // &quot;A&quot;</div><div class="line">linearDS.get_base_frame().get_reference_frame(); // &quot;A&quot;</div><div class="line"></div><div class="line">// evaluate a point C in frame A</div><div class="line">state_representation::CartesianState CinA(&quot;C&quot;, &quot;A&quot;);</div><div class="line">auto twist0 = linearDS.evaluate(CinA); // valid, twist is expressed in frame A</div><div class="line"></div><div class="line">// set the base from of the DS to be A expressed in the world frame</div><div class="line">state_representation::CartesianState AinWorld(&quot;A&quot;, &quot;world&quot;);</div><div class="line">linearDS.set_base_frame(AinWorld);</div><div class="line"></div><div class="line">linearDS.get_attractor().get_name();             // &quot;B&quot;</div><div class="line">linearDS.get_attractor().get_reference_frame();  // &quot;A&quot;</div><div class="line">linearDS.get_base_frame().get_name();            // &quot;A&quot;</div><div class="line">linearDS.get_base_frame().get_reference_frame(); // &quot;world&quot;</div><div class="line"></div><div class="line">// option 1: reference frame of the input is the same as the base frame </div><div class="line">// -&gt; reference frame of the input: &quot;A&quot;</div><div class="line">// -&gt; DS base frame: &quot;A&quot;</div><div class="line">// -&gt; reference frame of the output: &quot;A&quot;</div><div class="line">auto twist1 = linearDS.evaluate(CinA);</div><div class="line"></div><div class="line">// option 2: reference frame of the input is the same as the base frame </div><div class="line">// -&gt; reference frame of the input: &quot;world&quot;</div><div class="line">// -&gt; DS base frame reference frame: &quot;world&quot;</div><div class="line">// -&gt; reference frame of the output: &quot;world&quot;</div><div class="line">auto CinWorld = AinWorld * CinA;</div><div class="line">auto twist2 = linearDS.evaluate(CinWorld);</div><div class="line"></div><div class="line">// as a note, you can mix and match the approach as necessary.</div><div class="line">// the following is using option 1 with an additional external operation</div><div class="line">// to yield a final result equivalent to option 2.</div><div class="line">auto twist3 =  AinWorld * linearDS.evaluate(CinA);</div><div class="line">// twist2 === twist3</div></div><!-- fragment --><p>Note that the base frame can have its own velocity or other state properties, which are automatically combined with the DS result with respect to the common reference frame.</p>
<p>Setting the base frame of the DS has some benefits. In some cases, the state variable to be evaluated is not directly expressed in the frame of the DS. Similarly the output twist may need to be expressed in a different reference frame.</p>
<p>As a practical example, consider a case where the state of an end-effector is reported in the reference frame of a robot, while a linear attractor is expressed in some moving task frame. The robot controller expects a twist expressed in the robot frame. By updating the DS base frame with respect to the robot frame, any pre-transformation of the end-effector state or post-transformation of the twist can be avoided.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">state_representation::CartesianState EE(&quot;end_effector&quot;, &quot;robot&quot;);</div><div class="line">state_representation::CartesianState attractor(&quot;attractor&quot;, &quot;task&quot;);</div><div class="line">state_representation::CartesianState taskInRobot(&quot;task&quot;, &quot;robot&quot;);</div><div class="line"></div><div class="line">dynamical_systems::Linear&lt;state_representation::CartesianState&gt; linearDS(attractor);</div><div class="line"></div><div class="line">// control loop</div><div class="line">while (...) {</div><div class="line">  // update the EE state from robot feedback </div><div class="line">  EE.set_pose(...);</div><div class="line"></div><div class="line">  // update the state of the task with respect to the robot (for example, from optitrack)</div><div class="line">  taskInRobot.set_pose(...);</div><div class="line">  taskInRobot.set_linear_velocity(...);</div><div class="line">  taskInRobot.set_angular_velocity(...);</div><div class="line"></div><div class="line">  // now update the DS base frame</div><div class="line">  linearDS.set_base_frame(taskInRobot);</div><div class="line"></div><div class="line">  // find the twist in the robot reference frame </div><div class="line">  // directly from the end-effector position in the robot reference frame</div><div class="line">  auto twist = linearDS.evaluate(EE);</div><div class="line"></div><div class="line">  // send twist command to controller</div><div class="line">  update_controller(twist);</div><div class="line">}</div></div><!-- fragment --><h2>Circular</h2>
<p>The <b>Circular</b> DS is a limit cycle that rotates around a center point in an elliptical orbit, converging to a desired radius on a plane.</p>
<p>The direction of the rotation is positive around the local Z axis; this appears as a counter-clockwise rotation when viewed from "above".</p>
<p>This DS is defined only for the <code>CartesianState</code> type. In addition, it only acts in linear space, determining a linear velocity for a given position. It does not produce any angular velocity.</p>
<p>The Circular DS can be constructed with a <code>CartesianState</code> state and radius as an argument; the state position defines the center of the limit cycle, while the state orientation defines the inclination of the limit cycle plane. The radius has a default value of 1.</p>
<p>The internal representation of the limit cycle is a <code><a class="el" href="classstate__representation_1_1_ellipsoid.html">state_representation::Ellipsoid</a></code> type. When a state is used in the constructor, the limit cycle has a constant radius. If an elliptical limit cycle is desired, the DS can be constructed directly from an <code>Ellipsoid</code> type.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">// construct the circular DS limit cycle using a CartesianState center</div><div class="line">state_representation::CartesianState center(&quot;center&quot;);</div><div class="line"></div><div class="line">// default constructor (radius = 1)</div><div class="line">dynamical_systems::Circular circularDS1(center);</div><div class="line"></div><div class="line">// constructor with radius</div><div class="line">double radius = 2.0;</div><div class="line">dynamical_systems::Circular circularDS2(center, radius);</div><div class="line"></div><div class="line">// construct the circular DS limit cycle directly using an Ellipsoid type</div><div class="line">state_representation::Ellipsoid ellipse(&quot;limit_cycle&quot;);</div><div class="line">ellipse.set_center_state(center);</div><div class="line">ellipse.set_axis_lengths({radius, 2 * radius});</div><div class="line">dynamical_systems::Circular ellipticalDS(ellipse);</div></div><!-- fragment --><h3>Configuring the Circular DS</h3>
<p>The Circular DS has the following core parameters:</p>
<ul>
<li><b>limit_cycle</b>; the <code>Ellipsoid</code> object defining the limit cycle center, shape and inclination.</li>
<li><b>planar_gain</b>; the proportional gain acting in the local plane towards the limit cycle radius.</li>
<li><b>normal_gain</b>; the proportional gain acting towards the local plane.</li>
<li><b>circular_velocity</b>; the expected angular orbital velocity around the local origin. Setting this value negative reverses the direction of rotation. [rad/s]</li>
</ul>
<p>Each parameter has corresponding <code>set_</code> and <code>get_</code> functions.</p>
<p>The constructor takes additional optional arguments to define the gain and circular velocity. The scalar value for the gain sets both the planar and normal gain of the DS.</p>
<p>Note that the argument for the radius is only present when a <code>CartesianState</code> is provided, and not when an <code>Ellipsoid</code> is provided, as the radii are already parameters of the <code>Ellipsoid</code>. </p><div class="fragment"><div class="line">{c++}</div><div class="line">// construct the circular DS with optional parameters (default values are shown)</div><div class="line">double radius = 1.0;</div><div class="line">double gain = 1.0;</div><div class="line">double circular_velocity = M_PI / 2;</div><div class="line"></div><div class="line">// construction with a CartesianState center</div><div class="line">dynamical_systems::Circular circularDS(center, radius, gain, circular_velocity);</div><div class="line"></div><div class="line">// construction with an Ellipsoid ellipse</div><div class="line">dynamical_systems::Circular circularDS(ellipse, gain, circular_velocity);</div></div><!-- fragment --><p>In addition, the following helper are defined to configure the limit cycle behaviour.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">.set_center(CartesianState(&quot;center&quot;));  // sets the center position and orientation of the limit cycle</div><div class="line">.set_gain(1.0);                         // sets both planar and normal gain to the gain value</div><div class="line">.set_rotation_angle(0.0);               // sets a rotation offset around the local Z axis</div><div class="line">.set_radius(1.0);                       // sets both elliptical axes to the given radius (forces circle)</div><div class="line">.set_radiuses({1.0, 2.0});              // sets the length of each elliptical axis individually  </div></div><!-- fragment --><h2>Ring</h2>
<p>The <b>Ring</b> DS is similar to the <b>Circular</b> DS but is more parameterizable. In brief, the strength of the limit cycle can be configured with a width around the ring radius.</p>
<p>The direction of the ring orbit is a positive rotation around the local Z axis; this appears as a counter-clockwise rotation when viewed from "above". A clockwise rotation can be achieved by rotating the ring 180 degrees about its local X or Y axis.</p>
<p>It only supports the <code>CartesianState</code> type, and always acts in a circular ring.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">state_representation::CartesianState center(&quot;center&quot;);</div><div class="line">dynamical_systems::Ring ringDS(center);</div></div><!-- fragment --><h3>Configuring the Ring DS</h3>
<p>The Ring DS has the following core parameters:</p>
<ul>
<li><b>center</b>; the ring center <code>CartesianPose</code> expressed in the DS base reference frame. This sets both the origin center and the inclination of the ring plane.</li>
<li><b>rotation_offset</b>; the orientation offset of the orientational attractor in the ring frame.</li>
<li><b>radius</b>; the ring radius. [m]</li>
<li><b>width</b>; the distance from the radius where the velocity has tangential components around the ring. Beyond this width, the velocity is always perpendicular towards the radius. [m]</li>
<li><b>speed</b>; the desired linear speed when travelling along the circle radius. The limit cycle is only stable when the speed is positive. [m/s]</li>
<li><b>field_strength</b>; the scale factor applied to the ring speed outside of the radius + width zone.</li>
<li><b>normal_gain</b>; the scale factor for the speed normal to the ring plane.</li>
<li><b>angular_gain</b>; the scale factor for angular error restitution.</li>
</ul>
<p>Each parameter has corresponding <code>set_</code> and <code>get_</code> functions.</p>
<p>The constructor takes additional optional arguments to define the ring DS parameters. </p><div class="fragment"><div class="line">{c++}</div><div class="line">// construct the ring DS with optional parameters (default values are shown)</div><div class="line">double radius = 1.0;</div><div class="line">double width = 0.5;</div><div class="line">double speed = 1.0;</div><div class="line">double field_strength = 1.0;</div><div class="line">double normal_gain = 1.0;</div><div class="line">double angular_gain = 1.0;</div><div class="line">dynamical_systems::Ring ringDS(center, radius, width, speed, field_strength, normal_gain, angular_gain);</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
