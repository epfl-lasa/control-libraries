// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: state_representation/state_message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_state_5frepresentation_2fstate_5fmessage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_state_5frepresentation_2fstate_5fmessage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "state_representation/state.pb.h"
#include "state_representation/space/spatial_state.pb.h"
#include "state_representation/space/cartesian/cartesian_state.pb.h"
#include "state_representation/space/joint/jacobian.pb.h"
#include "state_representation/space/joint/joint_state.pb.h"
#include "state_representation/geometry/shape.pb.h"
#include "state_representation/geometry/ellipsoid.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_state_5frepresentation_2fstate_5fmessage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_state_5frepresentation_2fstate_5fmessage_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_state_5frepresentation_2fstate_5fmessage_2eproto;
namespace state_representation {
namespace proto {
class StateMessage;
struct StateMessageDefaultTypeInternal;
extern StateMessageDefaultTypeInternal _StateMessage_default_instance_;
}  // namespace proto
}  // namespace state_representation
PROTOBUF_NAMESPACE_OPEN
template<> ::state_representation::proto::StateMessage* Arena::CreateMaybeMessage<::state_representation::proto::StateMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace state_representation {
namespace proto {

// ===================================================================

class StateMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:state_representation.proto.StateMessage) */ {
 public:
  inline StateMessage() : StateMessage(nullptr) {}
  ~StateMessage() override;
  explicit constexpr StateMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateMessage(const StateMessage& from);
  StateMessage(StateMessage&& from) noexcept
    : StateMessage() {
    *this = ::std::move(from);
  }

  inline StateMessage& operator=(const StateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateMessage& operator=(StateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageTypeCase {
    kState = 1,
    kSpatialState = 2,
    kCartesianState = 3,
    kCartesianPose = 4,
    kCartesianTwist = 5,
    kCartesianWrench = 6,
    kJacobian = 7,
    kJointState = 8,
    kJointPositions = 9,
    kJointVelocities = 10,
    kJointTorques = 11,
    kShape = 12,
    kEllipsoid = 13,
    MESSAGE_TYPE_NOT_SET = 0,
  };

  static inline const StateMessage* internal_default_instance() {
    return reinterpret_cast<const StateMessage*>(
               &_StateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StateMessage& a, StateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StateMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StateMessage* New() const final {
    return new StateMessage();
  }

  StateMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StateMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StateMessage& from);
  void MergeFrom(const StateMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "state_representation.proto.StateMessage";
  }
  protected:
  explicit StateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
    kSpatialStateFieldNumber = 2,
    kCartesianStateFieldNumber = 3,
    kCartesianPoseFieldNumber = 4,
    kCartesianTwistFieldNumber = 5,
    kCartesianWrenchFieldNumber = 6,
    kJacobianFieldNumber = 7,
    kJointStateFieldNumber = 8,
    kJointPositionsFieldNumber = 9,
    kJointVelocitiesFieldNumber = 10,
    kJointTorquesFieldNumber = 11,
    kShapeFieldNumber = 12,
    kEllipsoidFieldNumber = 13,
  };
  // .state_representation.proto.State state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::state_representation::proto::State& state() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::state_representation::proto::State* release_state();
  ::state_representation::proto::State* mutable_state();
  void set_allocated_state(::state_representation::proto::State* state);
  private:
  const ::state_representation::proto::State& _internal_state() const;
  ::state_representation::proto::State* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::state_representation::proto::State* state);
  ::state_representation::proto::State* unsafe_arena_release_state();

  // .state_representation.proto.SpatialState spatial_state = 2;
  bool has_spatial_state() const;
  private:
  bool _internal_has_spatial_state() const;
  public:
  void clear_spatial_state();
  const ::state_representation::proto::SpatialState& spatial_state() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::state_representation::proto::SpatialState* release_spatial_state();
  ::state_representation::proto::SpatialState* mutable_spatial_state();
  void set_allocated_spatial_state(::state_representation::proto::SpatialState* spatial_state);
  private:
  const ::state_representation::proto::SpatialState& _internal_spatial_state() const;
  ::state_representation::proto::SpatialState* _internal_mutable_spatial_state();
  public:
  void unsafe_arena_set_allocated_spatial_state(
      ::state_representation::proto::SpatialState* spatial_state);
  ::state_representation::proto::SpatialState* unsafe_arena_release_spatial_state();

  // .state_representation.proto.CartesianState cartesian_state = 3;
  bool has_cartesian_state() const;
  private:
  bool _internal_has_cartesian_state() const;
  public:
  void clear_cartesian_state();
  const ::state_representation::proto::CartesianState& cartesian_state() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::state_representation::proto::CartesianState* release_cartesian_state();
  ::state_representation::proto::CartesianState* mutable_cartesian_state();
  void set_allocated_cartesian_state(::state_representation::proto::CartesianState* cartesian_state);
  private:
  const ::state_representation::proto::CartesianState& _internal_cartesian_state() const;
  ::state_representation::proto::CartesianState* _internal_mutable_cartesian_state();
  public:
  void unsafe_arena_set_allocated_cartesian_state(
      ::state_representation::proto::CartesianState* cartesian_state);
  ::state_representation::proto::CartesianState* unsafe_arena_release_cartesian_state();

  // .state_representation.proto.CartesianPose cartesian_pose = 4;
  bool has_cartesian_pose() const;
  private:
  bool _internal_has_cartesian_pose() const;
  public:
  void clear_cartesian_pose();
  const ::state_representation::proto::CartesianPose& cartesian_pose() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::state_representation::proto::CartesianPose* release_cartesian_pose();
  ::state_representation::proto::CartesianPose* mutable_cartesian_pose();
  void set_allocated_cartesian_pose(::state_representation::proto::CartesianPose* cartesian_pose);
  private:
  const ::state_representation::proto::CartesianPose& _internal_cartesian_pose() const;
  ::state_representation::proto::CartesianPose* _internal_mutable_cartesian_pose();
  public:
  void unsafe_arena_set_allocated_cartesian_pose(
      ::state_representation::proto::CartesianPose* cartesian_pose);
  ::state_representation::proto::CartesianPose* unsafe_arena_release_cartesian_pose();

  // .state_representation.proto.CartesianTwist cartesian_twist = 5;
  bool has_cartesian_twist() const;
  private:
  bool _internal_has_cartesian_twist() const;
  public:
  void clear_cartesian_twist();
  const ::state_representation::proto::CartesianTwist& cartesian_twist() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::state_representation::proto::CartesianTwist* release_cartesian_twist();
  ::state_representation::proto::CartesianTwist* mutable_cartesian_twist();
  void set_allocated_cartesian_twist(::state_representation::proto::CartesianTwist* cartesian_twist);
  private:
  const ::state_representation::proto::CartesianTwist& _internal_cartesian_twist() const;
  ::state_representation::proto::CartesianTwist* _internal_mutable_cartesian_twist();
  public:
  void unsafe_arena_set_allocated_cartesian_twist(
      ::state_representation::proto::CartesianTwist* cartesian_twist);
  ::state_representation::proto::CartesianTwist* unsafe_arena_release_cartesian_twist();

  // .state_representation.proto.CartesianWrench cartesian_wrench = 6;
  bool has_cartesian_wrench() const;
  private:
  bool _internal_has_cartesian_wrench() const;
  public:
  void clear_cartesian_wrench();
  const ::state_representation::proto::CartesianWrench& cartesian_wrench() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::state_representation::proto::CartesianWrench* release_cartesian_wrench();
  ::state_representation::proto::CartesianWrench* mutable_cartesian_wrench();
  void set_allocated_cartesian_wrench(::state_representation::proto::CartesianWrench* cartesian_wrench);
  private:
  const ::state_representation::proto::CartesianWrench& _internal_cartesian_wrench() const;
  ::state_representation::proto::CartesianWrench* _internal_mutable_cartesian_wrench();
  public:
  void unsafe_arena_set_allocated_cartesian_wrench(
      ::state_representation::proto::CartesianWrench* cartesian_wrench);
  ::state_representation::proto::CartesianWrench* unsafe_arena_release_cartesian_wrench();

  // .state_representation.proto.Jacobian jacobian = 7;
  bool has_jacobian() const;
  private:
  bool _internal_has_jacobian() const;
  public:
  void clear_jacobian();
  const ::state_representation::proto::Jacobian& jacobian() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::state_representation::proto::Jacobian* release_jacobian();
  ::state_representation::proto::Jacobian* mutable_jacobian();
  void set_allocated_jacobian(::state_representation::proto::Jacobian* jacobian);
  private:
  const ::state_representation::proto::Jacobian& _internal_jacobian() const;
  ::state_representation::proto::Jacobian* _internal_mutable_jacobian();
  public:
  void unsafe_arena_set_allocated_jacobian(
      ::state_representation::proto::Jacobian* jacobian);
  ::state_representation::proto::Jacobian* unsafe_arena_release_jacobian();

  // .state_representation.proto.JointState joint_state = 8;
  bool has_joint_state() const;
  private:
  bool _internal_has_joint_state() const;
  public:
  void clear_joint_state();
  const ::state_representation::proto::JointState& joint_state() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::state_representation::proto::JointState* release_joint_state();
  ::state_representation::proto::JointState* mutable_joint_state();
  void set_allocated_joint_state(::state_representation::proto::JointState* joint_state);
  private:
  const ::state_representation::proto::JointState& _internal_joint_state() const;
  ::state_representation::proto::JointState* _internal_mutable_joint_state();
  public:
  void unsafe_arena_set_allocated_joint_state(
      ::state_representation::proto::JointState* joint_state);
  ::state_representation::proto::JointState* unsafe_arena_release_joint_state();

  // .state_representation.proto.JointPositions joint_positions = 9;
  bool has_joint_positions() const;
  private:
  bool _internal_has_joint_positions() const;
  public:
  void clear_joint_positions();
  const ::state_representation::proto::JointPositions& joint_positions() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::state_representation::proto::JointPositions* release_joint_positions();
  ::state_representation::proto::JointPositions* mutable_joint_positions();
  void set_allocated_joint_positions(::state_representation::proto::JointPositions* joint_positions);
  private:
  const ::state_representation::proto::JointPositions& _internal_joint_positions() const;
  ::state_representation::proto::JointPositions* _internal_mutable_joint_positions();
  public:
  void unsafe_arena_set_allocated_joint_positions(
      ::state_representation::proto::JointPositions* joint_positions);
  ::state_representation::proto::JointPositions* unsafe_arena_release_joint_positions();

  // .state_representation.proto.JointVelocities joint_velocities = 10;
  bool has_joint_velocities() const;
  private:
  bool _internal_has_joint_velocities() const;
  public:
  void clear_joint_velocities();
  const ::state_representation::proto::JointVelocities& joint_velocities() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::state_representation::proto::JointVelocities* release_joint_velocities();
  ::state_representation::proto::JointVelocities* mutable_joint_velocities();
  void set_allocated_joint_velocities(::state_representation::proto::JointVelocities* joint_velocities);
  private:
  const ::state_representation::proto::JointVelocities& _internal_joint_velocities() const;
  ::state_representation::proto::JointVelocities* _internal_mutable_joint_velocities();
  public:
  void unsafe_arena_set_allocated_joint_velocities(
      ::state_representation::proto::JointVelocities* joint_velocities);
  ::state_representation::proto::JointVelocities* unsafe_arena_release_joint_velocities();

  // .state_representation.proto.JointTorques joint_torques = 11;
  bool has_joint_torques() const;
  private:
  bool _internal_has_joint_torques() const;
  public:
  void clear_joint_torques();
  const ::state_representation::proto::JointTorques& joint_torques() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::state_representation::proto::JointTorques* release_joint_torques();
  ::state_representation::proto::JointTorques* mutable_joint_torques();
  void set_allocated_joint_torques(::state_representation::proto::JointTorques* joint_torques);
  private:
  const ::state_representation::proto::JointTorques& _internal_joint_torques() const;
  ::state_representation::proto::JointTorques* _internal_mutable_joint_torques();
  public:
  void unsafe_arena_set_allocated_joint_torques(
      ::state_representation::proto::JointTorques* joint_torques);
  ::state_representation::proto::JointTorques* unsafe_arena_release_joint_torques();

  // .state_representation.proto.Shape shape = 12;
  bool has_shape() const;
  private:
  bool _internal_has_shape() const;
  public:
  void clear_shape();
  const ::state_representation::proto::Shape& shape() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::state_representation::proto::Shape* release_shape();
  ::state_representation::proto::Shape* mutable_shape();
  void set_allocated_shape(::state_representation::proto::Shape* shape);
  private:
  const ::state_representation::proto::Shape& _internal_shape() const;
  ::state_representation::proto::Shape* _internal_mutable_shape();
  public:
  void unsafe_arena_set_allocated_shape(
      ::state_representation::proto::Shape* shape);
  ::state_representation::proto::Shape* unsafe_arena_release_shape();

  // .state_representation.proto.Ellipsoid ellipsoid = 13;
  bool has_ellipsoid() const;
  private:
  bool _internal_has_ellipsoid() const;
  public:
  void clear_ellipsoid();
  const ::state_representation::proto::Ellipsoid& ellipsoid() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::state_representation::proto::Ellipsoid* release_ellipsoid();
  ::state_representation::proto::Ellipsoid* mutable_ellipsoid();
  void set_allocated_ellipsoid(::state_representation::proto::Ellipsoid* ellipsoid);
  private:
  const ::state_representation::proto::Ellipsoid& _internal_ellipsoid() const;
  ::state_representation::proto::Ellipsoid* _internal_mutable_ellipsoid();
  public:
  void unsafe_arena_set_allocated_ellipsoid(
      ::state_representation::proto::Ellipsoid* ellipsoid);
  ::state_representation::proto::Ellipsoid* unsafe_arena_release_ellipsoid();

  void clear_message_type();
  MessageTypeCase message_type_case() const;
  // @@protoc_insertion_point(class_scope:state_representation.proto.StateMessage)
 private:
  class _Internal;
  void set_has_state();
  void set_has_spatial_state();
  void set_has_cartesian_state();
  void set_has_cartesian_pose();
  void set_has_cartesian_twist();
  void set_has_cartesian_wrench();
  void set_has_jacobian();
  void set_has_joint_state();
  void set_has_joint_positions();
  void set_has_joint_velocities();
  void set_has_joint_torques();
  void set_has_shape();
  void set_has_ellipsoid();

  inline bool has_message_type() const;
  inline void clear_has_message_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MessageTypeUnion {
    constexpr MessageTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::state_representation::proto::State* state_;
    ::state_representation::proto::SpatialState* spatial_state_;
    ::state_representation::proto::CartesianState* cartesian_state_;
    ::state_representation::proto::CartesianPose* cartesian_pose_;
    ::state_representation::proto::CartesianTwist* cartesian_twist_;
    ::state_representation::proto::CartesianWrench* cartesian_wrench_;
    ::state_representation::proto::Jacobian* jacobian_;
    ::state_representation::proto::JointState* joint_state_;
    ::state_representation::proto::JointPositions* joint_positions_;
    ::state_representation::proto::JointVelocities* joint_velocities_;
    ::state_representation::proto::JointTorques* joint_torques_;
    ::state_representation::proto::Shape* shape_;
    ::state_representation::proto::Ellipsoid* ellipsoid_;
  } message_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_state_5frepresentation_2fstate_5fmessage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StateMessage

// .state_representation.proto.State state = 1;
inline bool StateMessage::_internal_has_state() const {
  return message_type_case() == kState;
}
inline bool StateMessage::has_state() const {
  return _internal_has_state();
}
inline void StateMessage::set_has_state() {
  _oneof_case_[0] = kState;
}
inline ::state_representation::proto::State* StateMessage::release_state() {
  // @@protoc_insertion_point(field_release:state_representation.proto.StateMessage.state)
  if (_internal_has_state()) {
    clear_has_message_type();
      ::state_representation::proto::State* temp = message_type_.state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::state_representation::proto::State& StateMessage::_internal_state() const {
  return _internal_has_state()
      ? *message_type_.state_
      : reinterpret_cast< ::state_representation::proto::State&>(::state_representation::proto::_State_default_instance_);
}
inline const ::state_representation::proto::State& StateMessage::state() const {
  // @@protoc_insertion_point(field_get:state_representation.proto.StateMessage.state)
  return _internal_state();
}
inline ::state_representation::proto::State* StateMessage::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:state_representation.proto.StateMessage.state)
  if (_internal_has_state()) {
    clear_has_message_type();
    ::state_representation::proto::State* temp = message_type_.state_;
    message_type_.state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_state(::state_representation::proto::State* state) {
  clear_message_type();
  if (state) {
    set_has_state();
    message_type_.state_ = state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:state_representation.proto.StateMessage.state)
}
inline ::state_representation::proto::State* StateMessage::_internal_mutable_state() {
  if (!_internal_has_state()) {
    clear_message_type();
    set_has_state();
    message_type_.state_ = CreateMaybeMessage< ::state_representation::proto::State >(GetArenaForAllocation());
  }
  return message_type_.state_;
}
inline ::state_representation::proto::State* StateMessage::mutable_state() {
  // @@protoc_insertion_point(field_mutable:state_representation.proto.StateMessage.state)
  return _internal_mutable_state();
}

// .state_representation.proto.SpatialState spatial_state = 2;
inline bool StateMessage::_internal_has_spatial_state() const {
  return message_type_case() == kSpatialState;
}
inline bool StateMessage::has_spatial_state() const {
  return _internal_has_spatial_state();
}
inline void StateMessage::set_has_spatial_state() {
  _oneof_case_[0] = kSpatialState;
}
inline ::state_representation::proto::SpatialState* StateMessage::release_spatial_state() {
  // @@protoc_insertion_point(field_release:state_representation.proto.StateMessage.spatial_state)
  if (_internal_has_spatial_state()) {
    clear_has_message_type();
      ::state_representation::proto::SpatialState* temp = message_type_.spatial_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.spatial_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::state_representation::proto::SpatialState& StateMessage::_internal_spatial_state() const {
  return _internal_has_spatial_state()
      ? *message_type_.spatial_state_
      : reinterpret_cast< ::state_representation::proto::SpatialState&>(::state_representation::proto::_SpatialState_default_instance_);
}
inline const ::state_representation::proto::SpatialState& StateMessage::spatial_state() const {
  // @@protoc_insertion_point(field_get:state_representation.proto.StateMessage.spatial_state)
  return _internal_spatial_state();
}
inline ::state_representation::proto::SpatialState* StateMessage::unsafe_arena_release_spatial_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:state_representation.proto.StateMessage.spatial_state)
  if (_internal_has_spatial_state()) {
    clear_has_message_type();
    ::state_representation::proto::SpatialState* temp = message_type_.spatial_state_;
    message_type_.spatial_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_spatial_state(::state_representation::proto::SpatialState* spatial_state) {
  clear_message_type();
  if (spatial_state) {
    set_has_spatial_state();
    message_type_.spatial_state_ = spatial_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:state_representation.proto.StateMessage.spatial_state)
}
inline ::state_representation::proto::SpatialState* StateMessage::_internal_mutable_spatial_state() {
  if (!_internal_has_spatial_state()) {
    clear_message_type();
    set_has_spatial_state();
    message_type_.spatial_state_ = CreateMaybeMessage< ::state_representation::proto::SpatialState >(GetArenaForAllocation());
  }
  return message_type_.spatial_state_;
}
inline ::state_representation::proto::SpatialState* StateMessage::mutable_spatial_state() {
  // @@protoc_insertion_point(field_mutable:state_representation.proto.StateMessage.spatial_state)
  return _internal_mutable_spatial_state();
}

// .state_representation.proto.CartesianState cartesian_state = 3;
inline bool StateMessage::_internal_has_cartesian_state() const {
  return message_type_case() == kCartesianState;
}
inline bool StateMessage::has_cartesian_state() const {
  return _internal_has_cartesian_state();
}
inline void StateMessage::set_has_cartesian_state() {
  _oneof_case_[0] = kCartesianState;
}
inline ::state_representation::proto::CartesianState* StateMessage::release_cartesian_state() {
  // @@protoc_insertion_point(field_release:state_representation.proto.StateMessage.cartesian_state)
  if (_internal_has_cartesian_state()) {
    clear_has_message_type();
      ::state_representation::proto::CartesianState* temp = message_type_.cartesian_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.cartesian_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::state_representation::proto::CartesianState& StateMessage::_internal_cartesian_state() const {
  return _internal_has_cartesian_state()
      ? *message_type_.cartesian_state_
      : reinterpret_cast< ::state_representation::proto::CartesianState&>(::state_representation::proto::_CartesianState_default_instance_);
}
inline const ::state_representation::proto::CartesianState& StateMessage::cartesian_state() const {
  // @@protoc_insertion_point(field_get:state_representation.proto.StateMessage.cartesian_state)
  return _internal_cartesian_state();
}
inline ::state_representation::proto::CartesianState* StateMessage::unsafe_arena_release_cartesian_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:state_representation.proto.StateMessage.cartesian_state)
  if (_internal_has_cartesian_state()) {
    clear_has_message_type();
    ::state_representation::proto::CartesianState* temp = message_type_.cartesian_state_;
    message_type_.cartesian_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_cartesian_state(::state_representation::proto::CartesianState* cartesian_state) {
  clear_message_type();
  if (cartesian_state) {
    set_has_cartesian_state();
    message_type_.cartesian_state_ = cartesian_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:state_representation.proto.StateMessage.cartesian_state)
}
inline ::state_representation::proto::CartesianState* StateMessage::_internal_mutable_cartesian_state() {
  if (!_internal_has_cartesian_state()) {
    clear_message_type();
    set_has_cartesian_state();
    message_type_.cartesian_state_ = CreateMaybeMessage< ::state_representation::proto::CartesianState >(GetArenaForAllocation());
  }
  return message_type_.cartesian_state_;
}
inline ::state_representation::proto::CartesianState* StateMessage::mutable_cartesian_state() {
  // @@protoc_insertion_point(field_mutable:state_representation.proto.StateMessage.cartesian_state)
  return _internal_mutable_cartesian_state();
}

// .state_representation.proto.CartesianPose cartesian_pose = 4;
inline bool StateMessage::_internal_has_cartesian_pose() const {
  return message_type_case() == kCartesianPose;
}
inline bool StateMessage::has_cartesian_pose() const {
  return _internal_has_cartesian_pose();
}
inline void StateMessage::set_has_cartesian_pose() {
  _oneof_case_[0] = kCartesianPose;
}
inline ::state_representation::proto::CartesianPose* StateMessage::release_cartesian_pose() {
  // @@protoc_insertion_point(field_release:state_representation.proto.StateMessage.cartesian_pose)
  if (_internal_has_cartesian_pose()) {
    clear_has_message_type();
      ::state_representation::proto::CartesianPose* temp = message_type_.cartesian_pose_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.cartesian_pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::state_representation::proto::CartesianPose& StateMessage::_internal_cartesian_pose() const {
  return _internal_has_cartesian_pose()
      ? *message_type_.cartesian_pose_
      : reinterpret_cast< ::state_representation::proto::CartesianPose&>(::state_representation::proto::_CartesianPose_default_instance_);
}
inline const ::state_representation::proto::CartesianPose& StateMessage::cartesian_pose() const {
  // @@protoc_insertion_point(field_get:state_representation.proto.StateMessage.cartesian_pose)
  return _internal_cartesian_pose();
}
inline ::state_representation::proto::CartesianPose* StateMessage::unsafe_arena_release_cartesian_pose() {
  // @@protoc_insertion_point(field_unsafe_arena_release:state_representation.proto.StateMessage.cartesian_pose)
  if (_internal_has_cartesian_pose()) {
    clear_has_message_type();
    ::state_representation::proto::CartesianPose* temp = message_type_.cartesian_pose_;
    message_type_.cartesian_pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_cartesian_pose(::state_representation::proto::CartesianPose* cartesian_pose) {
  clear_message_type();
  if (cartesian_pose) {
    set_has_cartesian_pose();
    message_type_.cartesian_pose_ = cartesian_pose;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:state_representation.proto.StateMessage.cartesian_pose)
}
inline ::state_representation::proto::CartesianPose* StateMessage::_internal_mutable_cartesian_pose() {
  if (!_internal_has_cartesian_pose()) {
    clear_message_type();
    set_has_cartesian_pose();
    message_type_.cartesian_pose_ = CreateMaybeMessage< ::state_representation::proto::CartesianPose >(GetArenaForAllocation());
  }
  return message_type_.cartesian_pose_;
}
inline ::state_representation::proto::CartesianPose* StateMessage::mutable_cartesian_pose() {
  // @@protoc_insertion_point(field_mutable:state_representation.proto.StateMessage.cartesian_pose)
  return _internal_mutable_cartesian_pose();
}

// .state_representation.proto.CartesianTwist cartesian_twist = 5;
inline bool StateMessage::_internal_has_cartesian_twist() const {
  return message_type_case() == kCartesianTwist;
}
inline bool StateMessage::has_cartesian_twist() const {
  return _internal_has_cartesian_twist();
}
inline void StateMessage::set_has_cartesian_twist() {
  _oneof_case_[0] = kCartesianTwist;
}
inline ::state_representation::proto::CartesianTwist* StateMessage::release_cartesian_twist() {
  // @@protoc_insertion_point(field_release:state_representation.proto.StateMessage.cartesian_twist)
  if (_internal_has_cartesian_twist()) {
    clear_has_message_type();
      ::state_representation::proto::CartesianTwist* temp = message_type_.cartesian_twist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.cartesian_twist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::state_representation::proto::CartesianTwist& StateMessage::_internal_cartesian_twist() const {
  return _internal_has_cartesian_twist()
      ? *message_type_.cartesian_twist_
      : reinterpret_cast< ::state_representation::proto::CartesianTwist&>(::state_representation::proto::_CartesianTwist_default_instance_);
}
inline const ::state_representation::proto::CartesianTwist& StateMessage::cartesian_twist() const {
  // @@protoc_insertion_point(field_get:state_representation.proto.StateMessage.cartesian_twist)
  return _internal_cartesian_twist();
}
inline ::state_representation::proto::CartesianTwist* StateMessage::unsafe_arena_release_cartesian_twist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:state_representation.proto.StateMessage.cartesian_twist)
  if (_internal_has_cartesian_twist()) {
    clear_has_message_type();
    ::state_representation::proto::CartesianTwist* temp = message_type_.cartesian_twist_;
    message_type_.cartesian_twist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_cartesian_twist(::state_representation::proto::CartesianTwist* cartesian_twist) {
  clear_message_type();
  if (cartesian_twist) {
    set_has_cartesian_twist();
    message_type_.cartesian_twist_ = cartesian_twist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:state_representation.proto.StateMessage.cartesian_twist)
}
inline ::state_representation::proto::CartesianTwist* StateMessage::_internal_mutable_cartesian_twist() {
  if (!_internal_has_cartesian_twist()) {
    clear_message_type();
    set_has_cartesian_twist();
    message_type_.cartesian_twist_ = CreateMaybeMessage< ::state_representation::proto::CartesianTwist >(GetArenaForAllocation());
  }
  return message_type_.cartesian_twist_;
}
inline ::state_representation::proto::CartesianTwist* StateMessage::mutable_cartesian_twist() {
  // @@protoc_insertion_point(field_mutable:state_representation.proto.StateMessage.cartesian_twist)
  return _internal_mutable_cartesian_twist();
}

// .state_representation.proto.CartesianWrench cartesian_wrench = 6;
inline bool StateMessage::_internal_has_cartesian_wrench() const {
  return message_type_case() == kCartesianWrench;
}
inline bool StateMessage::has_cartesian_wrench() const {
  return _internal_has_cartesian_wrench();
}
inline void StateMessage::set_has_cartesian_wrench() {
  _oneof_case_[0] = kCartesianWrench;
}
inline ::state_representation::proto::CartesianWrench* StateMessage::release_cartesian_wrench() {
  // @@protoc_insertion_point(field_release:state_representation.proto.StateMessage.cartesian_wrench)
  if (_internal_has_cartesian_wrench()) {
    clear_has_message_type();
      ::state_representation::proto::CartesianWrench* temp = message_type_.cartesian_wrench_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.cartesian_wrench_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::state_representation::proto::CartesianWrench& StateMessage::_internal_cartesian_wrench() const {
  return _internal_has_cartesian_wrench()
      ? *message_type_.cartesian_wrench_
      : reinterpret_cast< ::state_representation::proto::CartesianWrench&>(::state_representation::proto::_CartesianWrench_default_instance_);
}
inline const ::state_representation::proto::CartesianWrench& StateMessage::cartesian_wrench() const {
  // @@protoc_insertion_point(field_get:state_representation.proto.StateMessage.cartesian_wrench)
  return _internal_cartesian_wrench();
}
inline ::state_representation::proto::CartesianWrench* StateMessage::unsafe_arena_release_cartesian_wrench() {
  // @@protoc_insertion_point(field_unsafe_arena_release:state_representation.proto.StateMessage.cartesian_wrench)
  if (_internal_has_cartesian_wrench()) {
    clear_has_message_type();
    ::state_representation::proto::CartesianWrench* temp = message_type_.cartesian_wrench_;
    message_type_.cartesian_wrench_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_cartesian_wrench(::state_representation::proto::CartesianWrench* cartesian_wrench) {
  clear_message_type();
  if (cartesian_wrench) {
    set_has_cartesian_wrench();
    message_type_.cartesian_wrench_ = cartesian_wrench;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:state_representation.proto.StateMessage.cartesian_wrench)
}
inline ::state_representation::proto::CartesianWrench* StateMessage::_internal_mutable_cartesian_wrench() {
  if (!_internal_has_cartesian_wrench()) {
    clear_message_type();
    set_has_cartesian_wrench();
    message_type_.cartesian_wrench_ = CreateMaybeMessage< ::state_representation::proto::CartesianWrench >(GetArenaForAllocation());
  }
  return message_type_.cartesian_wrench_;
}
inline ::state_representation::proto::CartesianWrench* StateMessage::mutable_cartesian_wrench() {
  // @@protoc_insertion_point(field_mutable:state_representation.proto.StateMessage.cartesian_wrench)
  return _internal_mutable_cartesian_wrench();
}

// .state_representation.proto.Jacobian jacobian = 7;
inline bool StateMessage::_internal_has_jacobian() const {
  return message_type_case() == kJacobian;
}
inline bool StateMessage::has_jacobian() const {
  return _internal_has_jacobian();
}
inline void StateMessage::set_has_jacobian() {
  _oneof_case_[0] = kJacobian;
}
inline ::state_representation::proto::Jacobian* StateMessage::release_jacobian() {
  // @@protoc_insertion_point(field_release:state_representation.proto.StateMessage.jacobian)
  if (_internal_has_jacobian()) {
    clear_has_message_type();
      ::state_representation::proto::Jacobian* temp = message_type_.jacobian_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.jacobian_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::state_representation::proto::Jacobian& StateMessage::_internal_jacobian() const {
  return _internal_has_jacobian()
      ? *message_type_.jacobian_
      : reinterpret_cast< ::state_representation::proto::Jacobian&>(::state_representation::proto::_Jacobian_default_instance_);
}
inline const ::state_representation::proto::Jacobian& StateMessage::jacobian() const {
  // @@protoc_insertion_point(field_get:state_representation.proto.StateMessage.jacobian)
  return _internal_jacobian();
}
inline ::state_representation::proto::Jacobian* StateMessage::unsafe_arena_release_jacobian() {
  // @@protoc_insertion_point(field_unsafe_arena_release:state_representation.proto.StateMessage.jacobian)
  if (_internal_has_jacobian()) {
    clear_has_message_type();
    ::state_representation::proto::Jacobian* temp = message_type_.jacobian_;
    message_type_.jacobian_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_jacobian(::state_representation::proto::Jacobian* jacobian) {
  clear_message_type();
  if (jacobian) {
    set_has_jacobian();
    message_type_.jacobian_ = jacobian;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:state_representation.proto.StateMessage.jacobian)
}
inline ::state_representation::proto::Jacobian* StateMessage::_internal_mutable_jacobian() {
  if (!_internal_has_jacobian()) {
    clear_message_type();
    set_has_jacobian();
    message_type_.jacobian_ = CreateMaybeMessage< ::state_representation::proto::Jacobian >(GetArenaForAllocation());
  }
  return message_type_.jacobian_;
}
inline ::state_representation::proto::Jacobian* StateMessage::mutable_jacobian() {
  // @@protoc_insertion_point(field_mutable:state_representation.proto.StateMessage.jacobian)
  return _internal_mutable_jacobian();
}

// .state_representation.proto.JointState joint_state = 8;
inline bool StateMessage::_internal_has_joint_state() const {
  return message_type_case() == kJointState;
}
inline bool StateMessage::has_joint_state() const {
  return _internal_has_joint_state();
}
inline void StateMessage::set_has_joint_state() {
  _oneof_case_[0] = kJointState;
}
inline ::state_representation::proto::JointState* StateMessage::release_joint_state() {
  // @@protoc_insertion_point(field_release:state_representation.proto.StateMessage.joint_state)
  if (_internal_has_joint_state()) {
    clear_has_message_type();
      ::state_representation::proto::JointState* temp = message_type_.joint_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.joint_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::state_representation::proto::JointState& StateMessage::_internal_joint_state() const {
  return _internal_has_joint_state()
      ? *message_type_.joint_state_
      : reinterpret_cast< ::state_representation::proto::JointState&>(::state_representation::proto::_JointState_default_instance_);
}
inline const ::state_representation::proto::JointState& StateMessage::joint_state() const {
  // @@protoc_insertion_point(field_get:state_representation.proto.StateMessage.joint_state)
  return _internal_joint_state();
}
inline ::state_representation::proto::JointState* StateMessage::unsafe_arena_release_joint_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:state_representation.proto.StateMessage.joint_state)
  if (_internal_has_joint_state()) {
    clear_has_message_type();
    ::state_representation::proto::JointState* temp = message_type_.joint_state_;
    message_type_.joint_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_joint_state(::state_representation::proto::JointState* joint_state) {
  clear_message_type();
  if (joint_state) {
    set_has_joint_state();
    message_type_.joint_state_ = joint_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:state_representation.proto.StateMessage.joint_state)
}
inline ::state_representation::proto::JointState* StateMessage::_internal_mutable_joint_state() {
  if (!_internal_has_joint_state()) {
    clear_message_type();
    set_has_joint_state();
    message_type_.joint_state_ = CreateMaybeMessage< ::state_representation::proto::JointState >(GetArenaForAllocation());
  }
  return message_type_.joint_state_;
}
inline ::state_representation::proto::JointState* StateMessage::mutable_joint_state() {
  // @@protoc_insertion_point(field_mutable:state_representation.proto.StateMessage.joint_state)
  return _internal_mutable_joint_state();
}

// .state_representation.proto.JointPositions joint_positions = 9;
inline bool StateMessage::_internal_has_joint_positions() const {
  return message_type_case() == kJointPositions;
}
inline bool StateMessage::has_joint_positions() const {
  return _internal_has_joint_positions();
}
inline void StateMessage::set_has_joint_positions() {
  _oneof_case_[0] = kJointPositions;
}
inline ::state_representation::proto::JointPositions* StateMessage::release_joint_positions() {
  // @@protoc_insertion_point(field_release:state_representation.proto.StateMessage.joint_positions)
  if (_internal_has_joint_positions()) {
    clear_has_message_type();
      ::state_representation::proto::JointPositions* temp = message_type_.joint_positions_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.joint_positions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::state_representation::proto::JointPositions& StateMessage::_internal_joint_positions() const {
  return _internal_has_joint_positions()
      ? *message_type_.joint_positions_
      : reinterpret_cast< ::state_representation::proto::JointPositions&>(::state_representation::proto::_JointPositions_default_instance_);
}
inline const ::state_representation::proto::JointPositions& StateMessage::joint_positions() const {
  // @@protoc_insertion_point(field_get:state_representation.proto.StateMessage.joint_positions)
  return _internal_joint_positions();
}
inline ::state_representation::proto::JointPositions* StateMessage::unsafe_arena_release_joint_positions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:state_representation.proto.StateMessage.joint_positions)
  if (_internal_has_joint_positions()) {
    clear_has_message_type();
    ::state_representation::proto::JointPositions* temp = message_type_.joint_positions_;
    message_type_.joint_positions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_joint_positions(::state_representation::proto::JointPositions* joint_positions) {
  clear_message_type();
  if (joint_positions) {
    set_has_joint_positions();
    message_type_.joint_positions_ = joint_positions;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:state_representation.proto.StateMessage.joint_positions)
}
inline ::state_representation::proto::JointPositions* StateMessage::_internal_mutable_joint_positions() {
  if (!_internal_has_joint_positions()) {
    clear_message_type();
    set_has_joint_positions();
    message_type_.joint_positions_ = CreateMaybeMessage< ::state_representation::proto::JointPositions >(GetArenaForAllocation());
  }
  return message_type_.joint_positions_;
}
inline ::state_representation::proto::JointPositions* StateMessage::mutable_joint_positions() {
  // @@protoc_insertion_point(field_mutable:state_representation.proto.StateMessage.joint_positions)
  return _internal_mutable_joint_positions();
}

// .state_representation.proto.JointVelocities joint_velocities = 10;
inline bool StateMessage::_internal_has_joint_velocities() const {
  return message_type_case() == kJointVelocities;
}
inline bool StateMessage::has_joint_velocities() const {
  return _internal_has_joint_velocities();
}
inline void StateMessage::set_has_joint_velocities() {
  _oneof_case_[0] = kJointVelocities;
}
inline ::state_representation::proto::JointVelocities* StateMessage::release_joint_velocities() {
  // @@protoc_insertion_point(field_release:state_representation.proto.StateMessage.joint_velocities)
  if (_internal_has_joint_velocities()) {
    clear_has_message_type();
      ::state_representation::proto::JointVelocities* temp = message_type_.joint_velocities_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.joint_velocities_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::state_representation::proto::JointVelocities& StateMessage::_internal_joint_velocities() const {
  return _internal_has_joint_velocities()
      ? *message_type_.joint_velocities_
      : reinterpret_cast< ::state_representation::proto::JointVelocities&>(::state_representation::proto::_JointVelocities_default_instance_);
}
inline const ::state_representation::proto::JointVelocities& StateMessage::joint_velocities() const {
  // @@protoc_insertion_point(field_get:state_representation.proto.StateMessage.joint_velocities)
  return _internal_joint_velocities();
}
inline ::state_representation::proto::JointVelocities* StateMessage::unsafe_arena_release_joint_velocities() {
  // @@protoc_insertion_point(field_unsafe_arena_release:state_representation.proto.StateMessage.joint_velocities)
  if (_internal_has_joint_velocities()) {
    clear_has_message_type();
    ::state_representation::proto::JointVelocities* temp = message_type_.joint_velocities_;
    message_type_.joint_velocities_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_joint_velocities(::state_representation::proto::JointVelocities* joint_velocities) {
  clear_message_type();
  if (joint_velocities) {
    set_has_joint_velocities();
    message_type_.joint_velocities_ = joint_velocities;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:state_representation.proto.StateMessage.joint_velocities)
}
inline ::state_representation::proto::JointVelocities* StateMessage::_internal_mutable_joint_velocities() {
  if (!_internal_has_joint_velocities()) {
    clear_message_type();
    set_has_joint_velocities();
    message_type_.joint_velocities_ = CreateMaybeMessage< ::state_representation::proto::JointVelocities >(GetArenaForAllocation());
  }
  return message_type_.joint_velocities_;
}
inline ::state_representation::proto::JointVelocities* StateMessage::mutable_joint_velocities() {
  // @@protoc_insertion_point(field_mutable:state_representation.proto.StateMessage.joint_velocities)
  return _internal_mutable_joint_velocities();
}

// .state_representation.proto.JointTorques joint_torques = 11;
inline bool StateMessage::_internal_has_joint_torques() const {
  return message_type_case() == kJointTorques;
}
inline bool StateMessage::has_joint_torques() const {
  return _internal_has_joint_torques();
}
inline void StateMessage::set_has_joint_torques() {
  _oneof_case_[0] = kJointTorques;
}
inline ::state_representation::proto::JointTorques* StateMessage::release_joint_torques() {
  // @@protoc_insertion_point(field_release:state_representation.proto.StateMessage.joint_torques)
  if (_internal_has_joint_torques()) {
    clear_has_message_type();
      ::state_representation::proto::JointTorques* temp = message_type_.joint_torques_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.joint_torques_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::state_representation::proto::JointTorques& StateMessage::_internal_joint_torques() const {
  return _internal_has_joint_torques()
      ? *message_type_.joint_torques_
      : reinterpret_cast< ::state_representation::proto::JointTorques&>(::state_representation::proto::_JointTorques_default_instance_);
}
inline const ::state_representation::proto::JointTorques& StateMessage::joint_torques() const {
  // @@protoc_insertion_point(field_get:state_representation.proto.StateMessage.joint_torques)
  return _internal_joint_torques();
}
inline ::state_representation::proto::JointTorques* StateMessage::unsafe_arena_release_joint_torques() {
  // @@protoc_insertion_point(field_unsafe_arena_release:state_representation.proto.StateMessage.joint_torques)
  if (_internal_has_joint_torques()) {
    clear_has_message_type();
    ::state_representation::proto::JointTorques* temp = message_type_.joint_torques_;
    message_type_.joint_torques_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_joint_torques(::state_representation::proto::JointTorques* joint_torques) {
  clear_message_type();
  if (joint_torques) {
    set_has_joint_torques();
    message_type_.joint_torques_ = joint_torques;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:state_representation.proto.StateMessage.joint_torques)
}
inline ::state_representation::proto::JointTorques* StateMessage::_internal_mutable_joint_torques() {
  if (!_internal_has_joint_torques()) {
    clear_message_type();
    set_has_joint_torques();
    message_type_.joint_torques_ = CreateMaybeMessage< ::state_representation::proto::JointTorques >(GetArenaForAllocation());
  }
  return message_type_.joint_torques_;
}
inline ::state_representation::proto::JointTorques* StateMessage::mutable_joint_torques() {
  // @@protoc_insertion_point(field_mutable:state_representation.proto.StateMessage.joint_torques)
  return _internal_mutable_joint_torques();
}

// .state_representation.proto.Shape shape = 12;
inline bool StateMessage::_internal_has_shape() const {
  return message_type_case() == kShape;
}
inline bool StateMessage::has_shape() const {
  return _internal_has_shape();
}
inline void StateMessage::set_has_shape() {
  _oneof_case_[0] = kShape;
}
inline ::state_representation::proto::Shape* StateMessage::release_shape() {
  // @@protoc_insertion_point(field_release:state_representation.proto.StateMessage.shape)
  if (_internal_has_shape()) {
    clear_has_message_type();
      ::state_representation::proto::Shape* temp = message_type_.shape_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.shape_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::state_representation::proto::Shape& StateMessage::_internal_shape() const {
  return _internal_has_shape()
      ? *message_type_.shape_
      : reinterpret_cast< ::state_representation::proto::Shape&>(::state_representation::proto::_Shape_default_instance_);
}
inline const ::state_representation::proto::Shape& StateMessage::shape() const {
  // @@protoc_insertion_point(field_get:state_representation.proto.StateMessage.shape)
  return _internal_shape();
}
inline ::state_representation::proto::Shape* StateMessage::unsafe_arena_release_shape() {
  // @@protoc_insertion_point(field_unsafe_arena_release:state_representation.proto.StateMessage.shape)
  if (_internal_has_shape()) {
    clear_has_message_type();
    ::state_representation::proto::Shape* temp = message_type_.shape_;
    message_type_.shape_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_shape(::state_representation::proto::Shape* shape) {
  clear_message_type();
  if (shape) {
    set_has_shape();
    message_type_.shape_ = shape;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:state_representation.proto.StateMessage.shape)
}
inline ::state_representation::proto::Shape* StateMessage::_internal_mutable_shape() {
  if (!_internal_has_shape()) {
    clear_message_type();
    set_has_shape();
    message_type_.shape_ = CreateMaybeMessage< ::state_representation::proto::Shape >(GetArenaForAllocation());
  }
  return message_type_.shape_;
}
inline ::state_representation::proto::Shape* StateMessage::mutable_shape() {
  // @@protoc_insertion_point(field_mutable:state_representation.proto.StateMessage.shape)
  return _internal_mutable_shape();
}

// .state_representation.proto.Ellipsoid ellipsoid = 13;
inline bool StateMessage::_internal_has_ellipsoid() const {
  return message_type_case() == kEllipsoid;
}
inline bool StateMessage::has_ellipsoid() const {
  return _internal_has_ellipsoid();
}
inline void StateMessage::set_has_ellipsoid() {
  _oneof_case_[0] = kEllipsoid;
}
inline ::state_representation::proto::Ellipsoid* StateMessage::release_ellipsoid() {
  // @@protoc_insertion_point(field_release:state_representation.proto.StateMessage.ellipsoid)
  if (_internal_has_ellipsoid()) {
    clear_has_message_type();
      ::state_representation::proto::Ellipsoid* temp = message_type_.ellipsoid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_type_.ellipsoid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::state_representation::proto::Ellipsoid& StateMessage::_internal_ellipsoid() const {
  return _internal_has_ellipsoid()
      ? *message_type_.ellipsoid_
      : reinterpret_cast< ::state_representation::proto::Ellipsoid&>(::state_representation::proto::_Ellipsoid_default_instance_);
}
inline const ::state_representation::proto::Ellipsoid& StateMessage::ellipsoid() const {
  // @@protoc_insertion_point(field_get:state_representation.proto.StateMessage.ellipsoid)
  return _internal_ellipsoid();
}
inline ::state_representation::proto::Ellipsoid* StateMessage::unsafe_arena_release_ellipsoid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:state_representation.proto.StateMessage.ellipsoid)
  if (_internal_has_ellipsoid()) {
    clear_has_message_type();
    ::state_representation::proto::Ellipsoid* temp = message_type_.ellipsoid_;
    message_type_.ellipsoid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_ellipsoid(::state_representation::proto::Ellipsoid* ellipsoid) {
  clear_message_type();
  if (ellipsoid) {
    set_has_ellipsoid();
    message_type_.ellipsoid_ = ellipsoid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:state_representation.proto.StateMessage.ellipsoid)
}
inline ::state_representation::proto::Ellipsoid* StateMessage::_internal_mutable_ellipsoid() {
  if (!_internal_has_ellipsoid()) {
    clear_message_type();
    set_has_ellipsoid();
    message_type_.ellipsoid_ = CreateMaybeMessage< ::state_representation::proto::Ellipsoid >(GetArenaForAllocation());
  }
  return message_type_.ellipsoid_;
}
inline ::state_representation::proto::Ellipsoid* StateMessage::mutable_ellipsoid() {
  // @@protoc_insertion_point(field_mutable:state_representation.proto.StateMessage.ellipsoid)
  return _internal_mutable_ellipsoid();
}

inline bool StateMessage::has_message_type() const {
  return message_type_case() != MESSAGE_TYPE_NOT_SET;
}
inline void StateMessage::clear_has_message_type() {
  _oneof_case_[0] = MESSAGE_TYPE_NOT_SET;
}
inline StateMessage::MessageTypeCase StateMessage::message_type_case() const {
  return StateMessage::MessageTypeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace state_representation

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_state_5frepresentation_2fstate_5fmessage_2eproto
