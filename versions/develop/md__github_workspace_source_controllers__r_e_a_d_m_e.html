<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Control Libraries: Controllers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Control Libraries<span id="projectnumber">&#160;6.3.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Controllers </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >This library introduces a set of controllers to be used in robotic control-loop schemes.</p>
<p >All controllers have a common interface inheriting from the <code>IController&lt;S&gt;</code> class, which is templated to operate in a particular space <code>S</code>, namely Cartesian or joint space.</p>
<h1>Table of contents</h1>
<ul>
<li>Constructing a controller</li>
<li>Using a controller<ul>
<li>Parameters</li>
<li>Compute command</li>
</ul>
</li>
<li>Developing a new controller</li>
</ul>
<h1>Constructing a controller</h1>
<p >The <code>ControllerFactory&lt;S&gt;</code> provides construction helpers for controllers using a factory pattern. Specific controllers are created and injected into a common <code>shared_ptr&lt;IController&lt;S&gt;&gt;</code>.</p>
<p >The <code>CartesianControllerFactory</code> and <code>JointControllerFactory</code> are shortcuts for the Cartesian and joint space controller factories.</p>
<p >The factory provides a static function <code>create_controller</code>, which can take a number of inputs. The first input argument is always the controller type (defined in <code><a class="el" href="_controller_type_8hpp_source.html">controllers/ControllerType.hpp</a></code>).</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &quot;controllers/ControllerFactory.hpp&quot;</div>
<div class="line"> </div>
<div class="line">using namespace controllers;</div>
<div class="line">using namespace state_representation;</div>
<div class="line"> </div>
<div class="line">// create a Cartesian impedance controller</div>
<div class="line">std::shared_ptr&lt;IController&lt;CartesianState&gt;&gt; cart_ctrl;</div>
<div class="line">cart_ctrl = CartesianControllerFactory::create_controller(CONTROLLER_TYPE::IMPEDANCE);</div>
<div class="line"> </div>
<div class="line">// create a compliant Cartesian twist controller using &quot;auto&quot; to avoid verbose typing</div>
<div class="line">auto twist_ctrl = CartesianControllerFactory::create_controller(CONTROLLER_TYPE::COMPLIANT_TWIST);</div>
</div><!-- fragment --><p >The <code>create_controller</code> function also has an input for the number of control dimensions. The Cartesian factory ignores this input as the dimensionality can be automatically inferred for Cartesian controllers. For the joint-space factory however, the number of joints should be provided so that the controller can initialize all internal properties to the correct dimensionality.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">unsigned int number_of_joints = 7;</div>
<div class="line">auto joint_ctrl = JointControllerFactory::create_controller(CONTROLLER_TYPE::IMPEDANCE, number_of_joints);</div>
</div><!-- fragment --><p >Some controllers use a <code><a class="el" href="classrobot__model_1_1_model.html" title="The Model class is a wrapper around pinocchio dynamic computation library with state_representation e...">robot_model::Model</a></code> object for internal computation. This can be provided as an input to the <code>create_controller</code> function, in which case the number of dimensions is automatically inferred from the model.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &quot;controllers/ControllerFactory.hpp&quot;</div>
<div class="line">#include &quot;robot_model/Model.hpp&quot;</div>
<div class="line"> </div>
<div class="line">using namespace controllers;</div>
<div class="line"> </div>
<div class="line">// create a robot model</div>
<div class="line">auto robot = robot_model::Model(&quot;my_robot&quot;, &quot;/path/to/robot.urdf&quot;);</div>
<div class="line"> </div>
<div class="line">// create a joint-space dissipative controller with a robot model</div>
<div class="line">auto joint_ctrl = JointControllerFactory::create_controller(CONTROLLER_TYPE::DISSIPATIVE, robot);</div>
<div class="line"> </div>
<div class="line">// create a Cartesian impedance controller operating only on velocity error with a robot model</div>
<div class="line">auto twist_ctrl = CartesianControllerFactory::create_controller(CONTROLLER_TYPE::VELOCITY_IMPEDANCE, robot);</div>
</div><!-- fragment --><p >Finally, initial controller parameters can be passed to <code>create_controller</code> as a list. See the next section for more details on parameter configuration.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &quot;controllers/ControllerFactory.hpp&quot;</div>
<div class="line">#include &quot;state_representation/parameters/Parameter.hpp&quot;</div>
<div class="line"> </div>
<div class="line">using namespace controllers;</div>
<div class="line">using namespace state_representation;</div>
<div class="line"> </div>
<div class="line">std::list&lt;std::shared_ptr&lt;ParameterInterface&gt;&gt; parameters;</div>
<div class="line">parameters.emplace_back(make_shared_parameter(&quot;damping&quot;, 10.0));</div>
<div class="line">parameters.emplace_back(make_shared_parameter(&quot;stiffness&quot;, 5.0));</div>
<div class="line">parameters.emplace_back(make_shared_parameter(&quot;inertia&quot;, 1.0));</div>
<div class="line"> </div>
<div class="line">auto ctrl = CartesianControllerFactory::create_controller(CONTROLLER_TYPE::IMPEDANCE, parameters);</div>
</div><!-- fragment --><h1>Using a controller</h1>
<p >The controller factory returns a base class pointer <code>shared_ptr&lt;IController&lt;S&gt;&gt;</code> for the chosen state type <code>S</code>, pointing to an instance of a specific derived controller. This allows all controllers to share the same consistent interface for usage and configuration.</p>
<h2>Parameters</h2>
<p >Controllers support custom parameterization through the base interface using <code><a class="el" href="classstate__representation_1_1_parameter_map.html" title="A wrapper class to contain a map of Parameter pointers by name and provide robust access methods.">state_representation::ParameterMap</a></code> methods:</p><ul>
<li><code>get_parameters()</code></li>
<li><code>get_parameter(name)</code></li>
<li><code>get_parameter_value&lt;T&gt;(name)</code></li>
<li><code>set_parameters(parameters)</code></li>
<li><code>set_parameter(parameter)</code></li>
<li><code>set_parameter_value(name, value)</code></li>
</ul>
<p >These methods can be used after construction to get or set controller parameters. Refer to the documentation on <code><a class="el" href="classcontrollers_1_1_i_controller.html" title="Abstract class to define a controller in a desired state type, such as joint or Cartesian spaces.">controllers::IController</a>&lt;&gt;</code> and <code><a class="el" href="classstate__representation_1_1_parameter_map.html" title="A wrapper class to contain a map of Parameter pointers by name and provide robust access methods.">state_representation::ParameterMap</a></code> for more information.</p>
<p >For controllers that use a <code><a class="el" href="classrobot__model_1_1_model.html" title="The Model class is a wrapper around pinocchio dynamic computation library with state_representation e...">robot_model::Model</a></code> object, there are additional interface methods that can be used to get or set the current robot model. Note that changing the robot model dimensionality, reference frame or joint frames at runtime could cause unexpected behaviour.</p><ul>
<li><code>get_robot_model()</code></li>
<li><code>set_robot_model(robot_model)</code></li>
</ul>
<h2>Compute command</h2>
<p >The main purpose of each controller is the <code>compute_command</code> function, which calculates an output state from a desired command state and feedback state. For example, the impedance controller takes the error between the command state and the feedback state and multiplies it by some linear gains to compute the output state.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &quot;controllers/ControllerFactory.hpp&quot;</div>
<div class="line">#include &quot;state_representation/space/cartesian/CartesianState.hpp&quot;</div>
<div class="line"> </div>
<div class="line">using namespace controllers;</div>
<div class="line"> </div>
<div class="line">// create a Cartesian impedance controller</div>
<div class="line">auto ctrl = CartesianControllerFactory::create_controller(CONTROLLER_TYPE::IMPEDANCE);</div>
<div class="line"> </div>
<div class="line">auto command_state = CartesianState::Random(&quot;command&quot;);</div>
<div class="line">auto feedback_state = CartesianState::Random(&quot;feedback&quot;);</div>
<div class="line"> </div>
<div class="line">// compute the command output</div>
<div class="line">auto command_output = ctrl-&gt;compute_command(command_state, feedback_state);</div>
</div><!-- fragment --><p >For Cartesian controllers, <code>compute_command</code> is overloaded with extra parameters to enable direct computation of a joint-space command output. This is done using the Jacobian matrix relating task-space forces to joint-space torques. The Jacobian can be passed to <code>compute_command</code> directly if it is known. Alternatively, if the controller has been configured with an associated robot model, the Jacobian can be automatically derived from the current joint positions.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &quot;robot_model/Model.hpp&quot;</div>
<div class="line">#include &quot;state_representation/space/cartesian/JointState.hpp&quot;</div>
<div class="line"> </div>
<div class="line">using namespace state_representation;</div>
<div class="line"> </div>
<div class="line">// create a Cartesian impedance controller</div>
<div class="line">auto ctrl = CartesianControllerFactory::create_controller(CONTROLLER_TYPE::IMPEDANCE);</div>
<div class="line"> </div>
<div class="line">// create a robot model</div>
<div class="line">auto robot = robot_model::Model(&quot;my_robot&quot;, &quot;/path/to/robot.urdf&quot;);</div>
<div class="line"> </div>
<div class="line">// create some state variables</div>
<div class="line">auto current_joints = JointState::Random(robot.get_robot_name(), robot.get_number_of_joints());</div>
<div class="line">auto command_state = CartesianState::Random(&quot;command&quot;);</div>
<div class="line">auto feedback_state = CartesianState::Random(&quot;feedback&quot;);</div>
<div class="line"> </div>
<div class="line">// compute the command output in joint space using a manually calculated Jacobian</div>
<div class="line">auto jacobian = robot.compute_jacobian(current_joints);</div>
<div class="line">auto joint_command_output_1 = ctrl-&gt;compute_command(command_state, feedback_state, jacobian);</div>
<div class="line"> </div>
<div class="line">// the above is simply equivalent to:</div>
<div class="line">// joint_command = jacobian.transpose() * CartesianWrench(ctrl-&gt;compute_command(command_state, feedback_state));</div>
<div class="line"> </div>
<div class="line">// if controller has a robot model, compute the joint command by passing the current joint positions</div>
<div class="line">ctrl-&gt;set_robot_model(robot);</div>
<div class="line">auto joint_command_output_2 = ctrl-&gt;compute_command(command_state, feedback_state, current_joints);</div>
</div><!-- fragment --><h1>Developing a new controller</h1>
<p >To implement a new controller, you need to create a class that derives from the <code>IController</code> base class or any derived controller such as <code>Impedance</code>. This class can be templated to accept different input spaces (e.g. <code>CartesianState</code> or <code>JointState</code>) or specify the desired input space.</p>
<p >The derived controller should override <code>compute_command</code> to produce custom behaviour. In addition, if the controller has any parameters, you should:</p><ul>
<li>Add parameter pointers as class properties</li>
<li>Initialize and declare parameters in the constructor</li>
<li>Override the protected <code>validate_and_set_parameter</code> method</li>
</ul>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// MyCartesianController.hpp</div>
<div class="line">#include &quot;controllers/IController.hpp&quot;</div>
<div class="line">#include &quot;state_representation/space/cartesian/CartesianState.hpp&quot;</div>
<div class="line"> </div>
<div class="line">class MyCartesianController : public controllers::IController&lt;state_representation::CartesianState&gt; {</div>
<div class="line">public:</div>
<div class="line">  // initialize and declare parameters</div>
<div class="line">  MyCartesianController();</div>
<div class="line">  </div>
<div class="line">  // override this method to implement custom control logic</div>
<div class="line">  state_representation::CartesianState compute_command(</div>
<div class="line">      const state_representation::CartesianState&amp; desired_state,</div>
<div class="line">      const state_representation::CartesianState&amp; feedback_state</div>
<div class="line">  ) override;</div>
<div class="line">  </div>
<div class="line">protected:</div>
<div class="line">  // override this method to update controller configurations when a parameter is modified</div>
<div class="line">  void validate_and_set_parameter(const std::shared_ptr&lt;state_representation::ParameterInterface&gt;&amp; parameter) override;</div>
<div class="line">  </div>
<div class="line">  // add any additional parameters as class properties</div>
<div class="line">  std::shared_ptr&lt;state_representation::Parameter&lt;int&gt;&gt; foo_;</div>
<div class="line">  std::shared_ptr&lt;state_representation::Parameter&lt;double&gt;&gt; bar_;</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// MyCartesianController.cpp</div>
<div class="line">#include &quot;MyCartesianController.hpp&quot;</div>
<div class="line"> </div>
<div class="line">#include &quot;state_representation/exceptions/InvalidParameterException.hpp&quot;</div>
<div class="line"> </div>
<div class="line">using namespace state_representation;</div>
<div class="line"> </div>
<div class="line">namespace controllers {</div>
<div class="line"> </div>
<div class="line">// initialize parameters</div>
<div class="line">MyCartesianController::MyCartesianController() :</div>
<div class="line">    foo_(make_shared_parameter&lt;int&gt;(1)),</div>
<div class="line">    bar_(make_shared_parameter&lt;double&gt;(2.0)) {</div>
<div class="line">  // &quot;declare&quot; parameters by inserting them into the parameter list with an associated name</div>
<div class="line">  this-&gt;parameters_.insert(std::make_pair(&quot;foo&quot;, foo_));</div>
<div class="line">  this-&gt;parameters_.insert(std::make_pair(&quot;bar&quot;, bar_));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// implement the command logic</div>
<div class="line">CartesianState MyCartesianController::compute_command(</div>
<div class="line">    const CartesianState&amp; desired_state, const CartesianState&amp; feedback_state</div>
<div class="line">) {</div>
<div class="line">    CartesianState command = ...;</div>
<div class="line">    return command;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// implement parameter validation</div>
<div class="line">void MyCartesianController::validate_and_set_parameter(</div>
<div class="line">    const std::shared_ptr&lt;state_representation::ParameterInterface&gt;&amp; parameter</div>
<div class="line">) {</div>
<div class="line">  if (parameter-&gt;get_name() == &quot;foo&quot;) {</div>
<div class="line">    auto value = std::static_pointer_cast&lt;state_representation::Parameter&lt;int&gt;&gt;(parameter);</div>
<div class="line">    // if a parameter value is not supported by the controller, throw an InvalidParameterException</div>
<div class="line">    if (value &lt; 0 || value &gt; 10) {</div>
<div class="line">      throw exceptions::InvalidParameterException(&quot;Parameter foo must be in range [0 - 10]&quot;);</div>
<div class="line">    }</div>
<div class="line">    this-&gt;foo_-&gt;set_value(value);</div>
<div class="line">  } else if (parameter-&gt;get_name() == &quot;bar&quot;) {</div>
<div class="line">    this-&gt;bar_-&gt;set_value(std::static_pointer_cast&lt;state_representation::Parameter&lt;double&gt;&gt;(parameter));</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p >The main goal of this library is to reuse as much as possible the functionalities between controllers. Therefore, if your controller is a variation of an impedance controller that simply adds extra way of computing the damping or stiffness matrix (e.g. <code>Dissipative</code>), it should extend from it and reuse the main function calls. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
