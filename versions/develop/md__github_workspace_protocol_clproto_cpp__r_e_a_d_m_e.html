<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Control Libraries: clproto (C++)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Control Libraries<span id="projectnumber">&#160;6.0.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">clproto (C++) </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >This library provides a simple interface for encoding and decoding control library type objects to and from a serialized binary string representation (the wire format).</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;clproto.h&gt;</div>
<div class="line">#include &lt;state_representation/space/cartesian/CartesianState.hpp&gt;</div>
<div class="line"> </div>
<div class="line">auto state = state_representation::CartesianState::Random(&quot;frame&quot;);</div>
<div class="line"> </div>
<div class="line">// Encode the message into the wire format</div>
<div class="line">std::string message = clproto::encode(state);</div>
<div class="line"> </div>
<div class="line">// The type is automatically derived from the object,</div>
<div class="line">// but can also be provided explicitly</div>
<div class="line">clproto::encode&lt;state_representation::CartesianState&gt;(state);</div>
<div class="line"> </div>
<div class="line">// Decode the message back into an object</div>
<div class="line">auto new_state = clproto::decode&lt;state_representation::CartesianState&gt;(message);</div>
<div class="line"> </div>
<div class="line">// The previous method will throw an exception if the</div>
<div class="line">// message cannot be parsed into that object type.</div>
<div class="line">// For exception-safe decoding, pass an object by reference </div>
<div class="line">// to the decode function and check the bool return value</div>
<div class="line">state_representation::CartesianState state_reference;</div>
<div class="line">if (clproto::decode(message, state_reference)) {</div>
<div class="line">  // successful decoding, state_reference has been modified</div>
<div class="line">} else {</div>
<div class="line">  // unsuccessful decoding, exception is suppressed and state_reference is unmodified</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// If the message type is not known, use the following</div>
<div class="line">// methods to check the validity and type</div>
<div class="line">if (!clproto::is_valid(message)) {</div>
<div class="line">  // message cannot be decoded into any known type</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">clproto::MessageType type = clproto::check_message_type(msg);</div>
</div><!-- fragment --><h1>Combining multiple message into a packet</h1>
<p >The serialized binary string encoding of a state message is not self-delimiting. The consequence of this is that when multiple encoded messages are combined on the wire, it is not possible to know where the first message ends and the second one starts.</p>
<p >There will often be cases where it makes sense to combine multiple state messages into one high level message packet. For example, a robot might broadcast the <code>CartesianState</code> of its end-effector together with its <code>JointState</code>. A client controller might want to listen for the combined "Robot State" on a single subscription topic.</p>
<p >The clproto library facilitates this usage by providing the methods <code>pack_fields</code> and <code>unpack_fields</code>. An ordered vector of encoded messages are combined into a data packet by the <code>pack_fields</code> method. For N fields, it adds a message header with (N + 1) values, describing the number of fields and the data size of each ordered field method. This allows the <code>unpack_fields</code> method to split the encoded fields back into an ordered vector to be decoded.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;clproto.h&gt;</div>
<div class="line">#include &lt;state_representation/space/cartesian/CartesianState.hpp&gt;</div>
<div class="line">#include &lt;state_representation/space/joint/JointState.hpp&gt;</div>
<div class="line"> </div>
<div class="line">using namespace state_representation;</div>
<div class="line"> </div>
<div class="line">// A robot can produce multiple state messages</div>
<div class="line">auto cart_state = CartesianState::Random(&quot;robot_ee&quot;, &quot;robot_base&quot;);</div>
<div class="line">auto joint_state = JointState::Random(&quot;robot&quot;, 7);</div>
<div class="line"> </div>
<div class="line">// Encode each state variable and add them to an ordered vector</div>
<div class="line">std::vector&lt;std::string&gt; encoded_robot_state;</div>
<div class="line">encoded_robot_state.emplace_back(clproto::encode(cart_state));</div>
<div class="line">encoded_robot_state.emplace_back(clproto::encode(joint_state));</div>
<div class="line"> </div>
<div class="line">// Pack the message fields into a raw data buffer,</div>
<div class="line">// reserving sufficient space to contain all messages</div>
<div class="line">char encoded_packet_buffer[2 * CLPROTO_PACKING_MAX_FIELD_LENGTH];</div>
<div class="line">clproto::pack_fields(encoded_robot_state, encoded_packet_buffer);</div>
<div class="line"> </div>
<div class="line">// The message fields can also be packed into a std::string,</div>
<div class="line">// provided that sufficient space is reserved for all messages</div>
<div class="line">std::string encoded_packet_str;</div>
<div class="line">encoded_packet_str.reserve(2 * CLPROTO_PACKING_MAX_FIELD_LENGTH);</div>
<div class="line">clproto::pack_fields(encoded_robot_state, encoded_packet_str.data());</div>
<div class="line"> </div>
<div class="line">// Unpack a combined message packet back into an ordered vector of encoded state variables</div>
<div class="line">std::vector&lt;std::string&gt; unpacked_encoded_robot_state = clproto::unpack_fields(encoded_packet_buffer);</div>
<div class="line">// (or, for a string type encoded packet:)</div>
<div class="line">unpacked_encoded_robot_state = clproto::unpack_fields(encoded_packet_str.c_str());</div>
<div class="line"> </div>
<div class="line">// Finally, decode the encoded fields in the same order as the original packing</div>
<div class="line">auto decoded_cart_state = clproto::decode&lt;CartesianState&gt;(unpacked_encoded_robot_state.at(0));</div>
<div class="line">auto decoded_joint_state = clproto::decode&lt;JointState&gt;(unpacked_encoded_robot_state.at(1));</div>
</div><!-- fragment --><p >The pack / unpack methods are provided as a convenience only for simple synthesis of messages from core state message types. The communication implementation can always be extended further by the end user as necessary, for example to prepend an indication of the field types to the message, or to add other delimiting behaviour.</p>
<h2>ZMQ example</h2>
<p >The packing and unpacking of the message should be handled according to the network requirements. This sections shows an example for ZMQ messaging.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;zmq.h&gt;</div>
<div class="line"> </div>
<div class="line">// Combine encoded state messages into an ordered vector</div>
<div class="line">std::vector&lt;std::string&gt; encoded_robot_state = ...;</div>
<div class="line"> </div>
<div class="line">// Pack and publish the combined state messages, assuming a pre-configured publishing socket</div>
<div class="line">zmq::socket_t publisher;</div>
<div class="line">zmq::message_t zmq_message(encoded_robot_state.size() * CLPROTO_PACKING_MAX_FIELD_LENGTH);</div>
<div class="line">pack_fields(encoded_robot_state, static_cast&lt;char *&gt;(zmq_message.data()));</div>
<div class="line">publisher.send(zmq_message, zmq::send_flags::none);</div>
<div class="line"> </div>
<div class="line">// On the receiving side, cast the message data to a char pointer before unpacking</div>
<div class="line">zmq::message_t received_zmq_message;</div>
<div class="line">zmq::socket_t subscriber;</div>
<div class="line">auto result = subscriber.recv(received_zmq_message);</div>
<div class="line">if (result) {</div>
<div class="line">  received_encoded_robot_state = unpack_fields(static_cast&lt;const char*&gt;(received_zmq_message.data()));</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Reserving packet size</h2>
<p >Note that, because the packing function writes to a buffer through a raw pointer, the associated buffer must have enough reserved size to contain the entire packet. For simplicity, the message size can be reserved as <code>number_of_fields * CLPROTO_PACKING_MAX_FIELD_LENGTH</code>, but this is almost much larger than necessary. Since the resultant packed data is not self-delimiting, the actual data length cannot be calculated post-hoc.</p>
<p >If bandwidth is limited, the following formula can be used to calculate the minimum needed buffer size.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">std::vector&lt;std::string&gt; encoded_fields = ...;</div>
<div class="line"> </div>
<div class="line">// The packet header starts with N + 1 values of size clproto::field_length_t,</div>
<div class="line">// where N is the number of fields N. The first value stores the number of fields,</div>
<div class="line">// while the following N values store the data length of each respective field.</div>
<div class="line">std::size_t packet_size = sizeof(clproto::field_length_t) * (encoded_fields.size() + 1);</div>
<div class="line"> </div>
<div class="line">// Add the size of each field</div>
<div class="line">for (const auto&amp; field : encoded_fields) {</div>
<div class="line">  packet_size += field.size();</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
