<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Control Libraries: state_representation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Control Libraries
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">state_representation Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to define <a class="el" href="classstate__representation_1_1_cartesian_pose.html" title="Class to define CartesianPose in cartesian space as 3D position and quaternion based orientation...">CartesianPose</a> in cartesian space as 3D position and quaternion based orientation.  <a href="classstate__representation_1_1_cartesian_pose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to represent a state in Cartesian space.  <a href="classstate__representation_1_1_cartesian_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to define twist in cartesian space as 3D linear and angular velocity vectors.  <a href="classstate__representation_1_1_cartesian_twist.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_cartesian_wrench.html">CartesianWrench</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to define wrench in cartesian space as 3D force and torque vectors.  <a href="classstate__representation_1_1_cartesian_wrench.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_dual_quaternion_pose.html">DualQuaternionPose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to represent a Pose in Dual Quaternion space.  <a href="classstate__representation_1_1_dual_quaternion_pose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_dual_quaternion_state.html">DualQuaternionState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to represent a state in Dual Quaternion space.  <a href="classstate__representation_1_1_dual_quaternion_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_dual_quaternion_twist.html">DualQuaternionTwist</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to represent a Twist in Dual Quaternion space.  <a href="classstate__representation_1_1_dual_quaternion_twist.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_ellipsoid.html">Ellipsoid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_event.html">Event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event is a predicate with memory. Its purpose is to be true only once and change value only when the underlying predicate has changed from true to false and back to true since last reading.  <a href="classstate__representation_1_1_event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_jacobian.html">Jacobian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to define a robot <a class="el" href="classstate__representation_1_1_jacobian.html" title="Class to define a robot Jacobian matrix. ">Jacobian</a> matrix.  <a href="classstate__representation_1_1_jacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to define a positions of the joints.  <a href="classstate__representation_1_1_joint_positions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to define a state in joint space.  <a href="classstate__representation_1_1_joint_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to define torques of the joints.  <a href="classstate__representation_1_1_joint_torques.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to define velocities of the joints.  <a href="classstate__representation_1_1_joint_velocities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_parameter_interface.html">ParameterInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_predicate.html">Predicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A predicate is a boolean parameter as in the logic formalism.  <a href="classstate__representation_1_1_predicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_shape.html">Shape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_spatial_state.html">SpatialState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_state.html">State</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class to represent a state.  <a href="classstate__representation_1_1_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstate__representation_1_1_trajectory.html">Trajectory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a65e64875cc8437e40b1debd7ae30bcdc"><td class="memItemLeft" align="right" valign="top"><a id="a65e64875cc8437e40b1debd7ae30bcdc"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a65e64875cc8437e40b1debd7ae30bcdc">JointStateVariable</a> { <br />
&#160;&#160;<b>POSITIONS</b>, 
<b>VELOCITIES</b>, 
<b>ACCELERATIONS</b>, 
<b>TORQUES</b>, 
<br />
&#160;&#160;<b>ALL</b>
<br />
 }</td></tr>
<tr class="memdesc:a65e64875cc8437e40b1debd7ae30bcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum representing all the fields (positions, velocities, accelerations and torques) of the JointState. <br /></td></tr>
<tr class="separator:a65e64875cc8437e40b1debd7ae30bcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe69415f9fe26fa1b1a563b97873686"><td class="memItemLeft" align="right" valign="top"><a id="a9fe69415f9fe26fa1b1a563b97873686"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>CartesianStateVariable</b> { <br />
&#160;&#160;<b>POSITION</b>, 
<b>ORIENTATION</b>, 
<b>POSE</b>, 
<b>LINEAR_VELOCITY</b>, 
<br />
&#160;&#160;<b>ANGULAR_VELOCITY</b>, 
<b>TWIST</b>, 
<b>LINEAR_ACCELERATION</b>, 
<b>ANGULAR_ACCELERATION</b>, 
<br />
&#160;&#160;<b>ACCELERATIONS</b>, 
<b>FORCE</b>, 
<b>TORQUE</b>, 
<b>WRENCH</b>, 
<br />
&#160;&#160;<b>ALL</b>
<br />
 }</td></tr>
<tr class="separator:a9fe69415f9fe26fa1b1a563b97873686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8356a8dcadd21825f50bc1fd41a9e87"><td class="memItemLeft" align="right" valign="top"><a id="ab8356a8dcadd21825f50bc1fd41a9e87"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>StateType</b> { <br />
&#160;&#160;<b>STATE</b>, 
<b>CARTESIANSTATE</b>, 
<b>DUALQUATERNIONSTATE</b>, 
<b>JOINTSTATE</b>, 
<br />
&#160;&#160;<b>JACOBIANMATRIX</b>, 
<b>TRAJECTORY</b>, 
<b>GEOMETRY_SHAPE</b>, 
<b>GEOMETRY_ELLIPSOID</b>, 
<br />
&#160;&#160;<b>PARAMETER_DOUBLE</b>, 
<b>PARAMETER_DOUBLE_ARRAY</b>, 
<b>PARAMETER_BOOL</b>, 
<b>PARAMETER_BOOL_ARRAY</b>, 
<br />
&#160;&#160;<b>PARAMETER_STRING</b>, 
<b>PARAMETER_STRING_ARRAY</b>, 
<b>PARAMETER_CARTESIANSTATE</b>, 
<b>PARAMETER_CARTESIANPOSE</b>, 
<br />
&#160;&#160;<b>PARAMETER_JOINTSTATE</b>, 
<b>PARAMETER_JOINTPOSITIONS</b>, 
<b>PARAMETER_ELLIPSOID</b>, 
<b>PARAMETER_MATRIX</b>, 
<br />
&#160;&#160;<b>PARAMETER_VECTOR</b>
<br />
 }</td></tr>
<tr class="separator:ab8356a8dcadd21825f50bc1fd41a9e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a832ff2cdc279aeecd369f8c1dc920a9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a832ff2cdc279aeecd369f8c1dc920a9a">swap</a> (<a class="el" href="classstate__representation_1_1_jacobian.html">Jacobian</a> &amp;jacobian1, <a class="el" href="classstate__representation_1_1_jacobian.html">Jacobian</a> &amp;jacobian2)</td></tr>
<tr class="separator:a832ff2cdc279aeecd369f8c1dc920a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f5461a6788ad4bae174490255b486f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a31f5461a6788ad4bae174490255b486f">dist</a> (const <a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;s1, const <a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;s2, const <a class="el" href="namespacestate__representation.html#a65e64875cc8437e40b1debd7ae30bcdc">JointStateVariable</a> &amp;state_variable_type=JointStateVariable::ALL)</td></tr>
<tr class="memdesc:a31f5461a6788ad4bae174490255b486f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance between two <a class="el" href="classstate__representation_1_1_joint_state.html" title="Class to define a state in joint space. ">JointState</a>.  <a href="#a31f5461a6788ad4bae174490255b486f">More...</a><br /></td></tr>
<tr class="separator:a31f5461a6788ad4bae174490255b486f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb43830cd7d4bb607ab7aa93537c6df4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#aeb43830cd7d4bb607ab7aa93537c6df4">swap</a> (<a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;state1, <a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;state2)</td></tr>
<tr class="separator:aeb43830cd7d4bb607ab7aa93537c6df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d515e5b5252641cf0796315baef1f6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a19d515e5b5252641cf0796315baef1f6">dist</a> (const <a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> &amp;s1, const <a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> &amp;s2, const CartesianStateVariable &amp;state_variable_type=CartesianStateVariable::ALL)</td></tr>
<tr class="memdesc:a19d515e5b5252641cf0796315baef1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the distance between two CartesianStates  <a href="#a19d515e5b5252641cf0796315baef1f6">More...</a><br /></td></tr>
<tr class="separator:a19d515e5b5252641cf0796315baef1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b029559fdd5c2b0f67aeea8ce759a11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a7b029559fdd5c2b0f67aeea8ce759a11">swap</a> (<a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> &amp;state1, <a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> &amp;state2)</td></tr>
<tr class="separator:a7b029559fdd5c2b0f67aeea8ce759a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f179ef6871fd79ae70b847651fdd61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a12f179ef6871fd79ae70b847651fdd61">swap</a> (<a class="el" href="classstate__representation_1_1_spatial_state.html">SpatialState</a> &amp;state1, <a class="el" href="classstate__representation_1_1_spatial_state.html">SpatialState</a> &amp;state2)</td></tr>
<tr class="separator:a12f179ef6871fd79ae70b847651fdd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af345b0edaa0326532a3f5dce4072438a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#af345b0edaa0326532a3f5dce4072438a">swap</a> (<a class="el" href="classstate__representation_1_1_state.html">State</a> &amp;state1, <a class="el" href="classstate__representation_1_1_state.html">State</a> &amp;state2)</td></tr>
<tr class="separator:af345b0edaa0326532a3f5dce4072438a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d253fbc08f3cb1aba43c5295f6e234e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a8d253fbc08f3cb1aba43c5295f6e234e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_ellipsoid.html">Ellipsoid</a> &amp;ellipsoid)</td></tr>
<tr class="separator:a8d253fbc08f3cb1aba43c5295f6e234e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcc249941dfc96910558ddbf8236b4c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#adbcc249941dfc96910558ddbf8236b4c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_shape.html">Shape</a> &amp;shape)</td></tr>
<tr class="separator:adbcc249941dfc96910558ddbf8236b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969b23334623ecdbf50c9b4eb611a240"><td class="memItemLeft" align="right" valign="top"><a id="a969b23334623ecdbf50c9b4eb611a240"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_event.html">Event</a> &amp;event)</td></tr>
<tr class="separator:a969b23334623ecdbf50c9b4eb611a240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f634bbd4f26da04441442608416301b"><td class="memTemplParams" colspan="2"><a id="a8f634bbd4f26da04441442608416301b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f634bbd4f26da04441442608416301b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a>&lt; T &gt; &amp;parameter)</td></tr>
<tr class="separator:a8f634bbd4f26da04441442608416301b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b75e8198b9823b537836c17e236ac01"><td class="memItemLeft" align="right" valign="top"><a id="a0b75e8198b9823b537836c17e236ac01"></a>
template std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a>&lt; double &gt; &amp;parameter)</td></tr>
<tr class="separator:a0b75e8198b9823b537836c17e236ac01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35929d90aa224ae8d5b60dace7e6545"><td class="memItemLeft" align="right" valign="top"><a id="af35929d90aa224ae8d5b60dace7e6545"></a>
template std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a>&lt; bool &gt; &amp;parameter)</td></tr>
<tr class="separator:af35929d90aa224ae8d5b60dace7e6545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39b01b7e2b2eddb4977aa7364067ba7"><td class="memItemLeft" align="right" valign="top"><a id="aa39b01b7e2b2eddb4977aa7364067ba7"></a>
template std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a>&lt; std::string &gt; &amp;parameter)</td></tr>
<tr class="separator:aa39b01b7e2b2eddb4977aa7364067ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af559965884c82a030a02776f5479ffd6"><td class="memItemLeft" align="right" valign="top"><a id="af559965884c82a030a02776f5479ffd6"></a>
template std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a>&lt; <a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> &gt; &amp;parameter)</td></tr>
<tr class="separator:af559965884c82a030a02776f5479ffd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae0110867cc0cc7b02fd4ed4f7a1979"><td class="memItemLeft" align="right" valign="top"><a id="a2ae0110867cc0cc7b02fd4ed4f7a1979"></a>
template std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a>&lt; <a class="el" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a> &gt; &amp;parameter)</td></tr>
<tr class="separator:a2ae0110867cc0cc7b02fd4ed4f7a1979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e2cc4afd149b1154fea40c65b6d3ba"><td class="memItemLeft" align="right" valign="top"><a id="a22e2cc4afd149b1154fea40c65b6d3ba"></a>
template std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a>&lt; <a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &gt; &amp;parameter)</td></tr>
<tr class="separator:a22e2cc4afd149b1154fea40c65b6d3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c0ed1b50727360c9cf7e52fa28abf1"><td class="memItemLeft" align="right" valign="top"><a id="ae1c0ed1b50727360c9cf7e52fa28abf1"></a>
template std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a>&lt; <a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> &gt; &amp;parameter)</td></tr>
<tr class="separator:ae1c0ed1b50727360c9cf7e52fa28abf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6daa40eb7e5dc6e5f313c4a457ea4d80"><td class="memItemLeft" align="right" valign="top"><a id="a6daa40eb7e5dc6e5f313c4a457ea4d80"></a>
template std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a>&lt; <a class="el" href="classstate__representation_1_1_ellipsoid.html">Ellipsoid</a> &gt; &amp;parameter)</td></tr>
<tr class="separator:a6daa40eb7e5dc6e5f313c4a457ea4d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9145427abe581c8ccd7a5b3e3bf32469"><td class="memItemLeft" align="right" valign="top"><a id="a9145427abe581c8ccd7a5b3e3bf32469"></a>
template std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a>&lt; Eigen::MatrixXd &gt; &amp;parameter)</td></tr>
<tr class="separator:a9145427abe581c8ccd7a5b3e3bf32469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce26842f86041e3688925c88bb4e6fc"><td class="memItemLeft" align="right" valign="top"><a id="a9ce26842f86041e3688925c88bb4e6fc"></a>
template std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a>&lt; Eigen::VectorXd &gt; &amp;parameter)</td></tr>
<tr class="separator:a9ce26842f86041e3688925c88bb4e6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ff6c9d6b19375bdca41c127e5c334d"><td class="memTemplParams" colspan="2"><a id="ae1ff6c9d6b19375bdca41c127e5c334d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae1ff6c9d6b19375bdca41c127e5c334d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a>&lt; std::vector&lt; double &gt;&gt; &amp;parameter)</td></tr>
<tr class="separator:ae1ff6c9d6b19375bdca41c127e5c334d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1c20765781eafc06e3e13a61d66582"><td class="memTemplParams" colspan="2"><a id="a2f1c20765781eafc06e3e13a61d66582"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2f1c20765781eafc06e3e13a61d66582"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a>&lt; std::vector&lt; bool &gt;&gt; &amp;parameter)</td></tr>
<tr class="separator:a2f1c20765781eafc06e3e13a61d66582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae733b906e7412688e88194a594cfe832"><td class="memTemplParams" colspan="2"><a id="ae733b906e7412688e88194a594cfe832"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae733b906e7412688e88194a594cfe832"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_parameter.html">Parameter</a>&lt; std::vector&lt; std::string &gt;&gt; &amp;parameter)</td></tr>
<tr class="separator:ae733b906e7412688e88194a594cfe832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffbc4ed7807b6fcc474407a74619acc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a8ffbc4ed7807b6fcc474407a74619acc">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_predicate.html">Predicate</a> &amp;predicate)</td></tr>
<tr class="separator:a8ffbc4ed7807b6fcc474407a74619acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a51f5f098aa3fa2b8eec12a93e37694"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a9a51f5f098aa3fa2b8eec12a93e37694">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_jacobian.html">Jacobian</a> &amp;jacobian)</td></tr>
<tr class="separator:a9a51f5f098aa3fa2b8eec12a93e37694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f0ee08214ae0f7f1354b0f6e858767"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_jacobian.html">Jacobian</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a74f0ee08214ae0f7f1354b0f6e858767">operator*</a> (const <a class="el" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a> &amp;pose, const <a class="el" href="classstate__representation_1_1_jacobian.html">Jacobian</a> &amp;jacobian)</td></tr>
<tr class="separator:a74f0ee08214ae0f7f1354b0f6e858767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1aa2faa1692a0c73ce73b8bada8550"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a4d1aa2faa1692a0c73ce73b8bada8550">operator*</a> (const Eigen::MatrixXd &amp;matrix, const <a class="el" href="classstate__representation_1_1_jacobian.html">Jacobian</a> &amp;jacobian)</td></tr>
<tr class="separator:a4d1aa2faa1692a0c73ce73b8bada8550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bf41b61d156b78b76c6a43ac1c2910"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#ac1bf41b61d156b78b76c6a43ac1c2910">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> &amp;positions)</td></tr>
<tr class="separator:ac1bf41b61d156b78b76c6a43ac1c2910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576c45b2950c5ac7d9500fd6f6c59faf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a576c45b2950c5ac7d9500fd6f6c59faf">operator*</a> (double lambda, const <a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> &amp;positions)</td></tr>
<tr class="separator:a576c45b2950c5ac7d9500fd6f6c59faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c6f4cfa69519364eb125984ede495d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a92c6f4cfa69519364eb125984ede495d">operator*</a> (const Eigen::ArrayXd &amp;lambda, const <a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> &amp;positions)</td></tr>
<tr class="separator:a92c6f4cfa69519364eb125984ede495d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9019045800d04022d1bade922e94e841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a9019045800d04022d1bade922e94e841">operator*</a> (const Eigen::MatrixXd &amp;lambda, const <a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> &amp;positions)</td></tr>
<tr class="separator:a9019045800d04022d1bade922e94e841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a259b5ad26441cd2b43a435761cc51"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#aa9a259b5ad26441cd2b43a435761cc51">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;state)</td></tr>
<tr class="separator:aa9a259b5ad26441cd2b43a435761cc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae488033c3315bd3004118c826743d9b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#ae488033c3315bd3004118c826743d9b7">operator*</a> (double lambda, const <a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;state)</td></tr>
<tr class="separator:ae488033c3315bd3004118c826743d9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df08c49ebb7a5b7fd6045b160fdcb00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a9df08c49ebb7a5b7fd6045b160fdcb00">operator*</a> (const Eigen::MatrixXd &amp;lambda, const <a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;state)</td></tr>
<tr class="separator:a9df08c49ebb7a5b7fd6045b160fdcb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940ca9b0d08c680b266ff48e33c48754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a940ca9b0d08c680b266ff48e33c48754">operator*</a> (const Eigen::ArrayXd &amp;lambda, const <a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;state)</td></tr>
<tr class="separator:a940ca9b0d08c680b266ff48e33c48754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a1f1c5f2450f68282a298f835d6dab"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a33a1f1c5f2450f68282a298f835d6dab">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a> &amp;torques)</td></tr>
<tr class="separator:a33a1f1c5f2450f68282a298f835d6dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e012e68f9c15706a30102f01ccfa057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a4e012e68f9c15706a30102f01ccfa057">operator*</a> (double lambda, const <a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a> &amp;torques)</td></tr>
<tr class="separator:a4e012e68f9c15706a30102f01ccfa057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1500017a20744b0795b8e7bcc54c6faa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a1500017a20744b0795b8e7bcc54c6faa">operator*</a> (const Eigen::ArrayXd &amp;lambda, const <a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a> &amp;torques)</td></tr>
<tr class="separator:a1500017a20744b0795b8e7bcc54c6faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7568276bd5f56d86c48480aca1937980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a7568276bd5f56d86c48480aca1937980">operator*</a> (const Eigen::MatrixXd &amp;lambda, const <a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a> &amp;torques)</td></tr>
<tr class="separator:a7568276bd5f56d86c48480aca1937980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02014f17b7fbfa1c6190a13fb242073"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#ab02014f17b7fbfa1c6190a13fb242073">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> &amp;velocities)</td></tr>
<tr class="separator:ab02014f17b7fbfa1c6190a13fb242073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7388fc5de6943b1f02e8ada69101e814"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a7388fc5de6943b1f02e8ada69101e814">operator*</a> (double lambda, const <a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> &amp;velocities)</td></tr>
<tr class="separator:a7388fc5de6943b1f02e8ada69101e814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308e5f0c96d5ba3adf557042cc7260f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a308e5f0c96d5ba3adf557042cc7260f6">operator*</a> (const Eigen::ArrayXd &amp;lambda, const <a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> &amp;velocities)</td></tr>
<tr class="separator:a308e5f0c96d5ba3adf557042cc7260f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17eed679b5d1d20668d0e83683d0d114"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a17eed679b5d1d20668d0e83683d0d114">operator*</a> (const Eigen::MatrixXd &amp;lambda, const <a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> &amp;velocities)</td></tr>
<tr class="separator:a17eed679b5d1d20668d0e83683d0d114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7eda6bcdb34de72612278c643813e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#aed7eda6bcdb34de72612278c643813e5">operator*</a> (const std::chrono::nanoseconds &amp;dt, const <a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> &amp;velocities)</td></tr>
<tr class="separator:aed7eda6bcdb34de72612278c643813e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323b4cab976a7171e8b9c04763f3c3fa"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a323b4cab976a7171e8b9c04763f3c3fa">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a> &amp;pose)</td></tr>
<tr class="separator:a323b4cab976a7171e8b9c04763f3c3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3767990e6f6c87c67ce7a7440c4ff2df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a3767990e6f6c87c67ce7a7440c4ff2df">operator*</a> (double lambda, const <a class="el" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a> &amp;pose)</td></tr>
<tr class="separator:a3767990e6f6c87c67ce7a7440c4ff2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4678bb5acdf070f0039eff1d8032fd"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a7c4678bb5acdf070f0039eff1d8032fd">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> &amp;state)</td></tr>
<tr class="separator:a7c4678bb5acdf070f0039eff1d8032fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9a517c3521af7a5d3439305d6756f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a5a9a517c3521af7a5d3439305d6756f7">operator*</a> (double lambda, const <a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> &amp;state)</td></tr>
<tr class="separator:a5a9a517c3521af7a5d3439305d6756f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3d53ca08f32ae9fa382b1f8602e300"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a7e3d53ca08f32ae9fa382b1f8602e300">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a> &amp;twist)</td></tr>
<tr class="separator:a7e3d53ca08f32ae9fa382b1f8602e300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a56e7a3754284d4646e18d07214cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a23a56e7a3754284d4646e18d07214cbe">operator*</a> (double lambda, const <a class="el" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a> &amp;twist)</td></tr>
<tr class="separator:a23a56e7a3754284d4646e18d07214cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237f512819d023e72fdd7e25823ac598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a237f512819d023e72fdd7e25823ac598">operator*</a> (const Eigen::Matrix&lt; double, 6, 6 &gt; &amp;lambda, const <a class="el" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a> &amp;twist)</td></tr>
<tr class="separator:a237f512819d023e72fdd7e25823ac598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3243044b171a3282f32bda0cfba683"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#abe3243044b171a3282f32bda0cfba683">operator*</a> (const std::chrono::nanoseconds &amp;dt, const <a class="el" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a> &amp;twist)</td></tr>
<tr class="separator:abe3243044b171a3282f32bda0cfba683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453657a4ff8913f8dcf07727b57f8299"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a453657a4ff8913f8dcf07727b57f8299">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_cartesian_wrench.html">CartesianWrench</a> &amp;wrench)</td></tr>
<tr class="separator:a453657a4ff8913f8dcf07727b57f8299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ecf01ef6c32f0774960cc594c3c3ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstate__representation_1_1_cartesian_wrench.html">CartesianWrench</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#ad0ecf01ef6c32f0774960cc594c3c3ee">operator*</a> (double lambda, const <a class="el" href="classstate__representation_1_1_cartesian_wrench.html">CartesianWrench</a> &amp;wrench)</td></tr>
<tr class="separator:ad0ecf01ef6c32f0774960cc594c3c3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f74c47f1b651b4110cdcb5910eb967"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstate__representation_1_1_dual_quaternion_state.html">DualQuaternionState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#aa4f74c47f1b651b4110cdcb5910eb967">log</a> (const <a class="el" href="classstate__representation_1_1_dual_quaternion_pose.html">DualQuaternionPose</a> &amp;state)</td></tr>
<tr class="separator:aa4f74c47f1b651b4110cdcb5910eb967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1763cbeb882101adea1eb25ca812bf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#aac1763cbeb882101adea1eb25ca812bf">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_dual_quaternion_pose.html">DualQuaternionPose</a> &amp;state)</td></tr>
<tr class="separator:aac1763cbeb882101adea1eb25ca812bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5278dab9a7ce390edf9fff11629f10"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstate__representation_1_1_dual_quaternion_state.html">DualQuaternionState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#afd5278dab9a7ce390edf9fff11629f10">operator*</a> (const float &amp;lambda, const <a class="el" href="classstate__representation_1_1_dual_quaternion_state.html">DualQuaternionState</a> &amp;state)</td></tr>
<tr class="separator:afd5278dab9a7ce390edf9fff11629f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7902f9c04e14b09cea083fef52bab63d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstate__representation_1_1_dual_quaternion_state.html">DualQuaternionState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a7902f9c04e14b09cea083fef52bab63d">exp</a> (const <a class="el" href="classstate__representation_1_1_dual_quaternion_state.html">DualQuaternionState</a> &amp;state)</td></tr>
<tr class="separator:a7902f9c04e14b09cea083fef52bab63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ec8c9bc8ac5d07af242028030da487"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#ac4ec8c9bc8ac5d07af242028030da487">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_dual_quaternion_state.html">DualQuaternionState</a> &amp;state)</td></tr>
<tr class="separator:ac4ec8c9bc8ac5d07af242028030da487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600552d3b0b2c2e6e1e36c13146d252b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a600552d3b0b2c2e6e1e36c13146d252b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_dual_quaternion_twist.html">DualQuaternionTwist</a> &amp;state)</td></tr>
<tr class="separator:a600552d3b0b2c2e6e1e36c13146d252b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f56d40b4a1bbe15bd985ab8b83dee0"><td class="memItemLeft" align="right" valign="top"><a id="a12f56d40b4a1bbe15bd985ab8b83dee0"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_spatial_state.html">SpatialState</a> &amp;state)</td></tr>
<tr class="separator:a12f56d40b4a1bbe15bd985ab8b83dee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a18748c983b2f629f88399e1229a41"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestate__representation.html#a21a18748c983b2f629f88399e1229a41">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classstate__representation_1_1_state.html">State</a> &amp;state)</td></tr>
<tr class="separator:a21a18748c983b2f629f88399e1229a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Baptiste Busch </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019/09/09</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Baptiste Busch </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019/09/13</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Baptiste Busch </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019/06/07</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Baptiste Busch </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019/04/16 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a31f5461a6788ad4bae174490255b486f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f5461a6788ad4bae174490255b486f">&#9670;&nbsp;</a></span>dist() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double state_representation::dist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacestate__representation.html#a65e64875cc8437e40b1debd7ae30bcdc">JointStateVariable</a> &amp;&#160;</td>
          <td class="paramname"><em>state_variable_type</em> = <code>JointStateVariable::ALL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the distance between two <a class="el" href="classstate__representation_1_1_joint_state.html" title="Class to define a state in joint space. ">JointState</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>the first <a class="el" href="classstate__representation_1_1_joint_state.html" title="Class to define a state in joint space. ">JointState</a> </td></tr>
    <tr><td class="paramname">s2</td><td>the second <a class="el" href="classstate__representation_1_1_joint_state.html" title="Class to define a state in joint space. ">JointState</a> </td></tr>
    <tr><td class="paramname">state_variable_type</td><td>name of the field from the JointStateVariable structure to apply the distance on (default ALL for full distance across all dimensions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the two states </dd></dl>

</div>
</div>
<a id="a19d515e5b5252641cf0796315baef1f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d515e5b5252641cf0796315baef1f6">&#9670;&nbsp;</a></span>dist() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double state_representation::dist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CartesianStateVariable &amp;&#160;</td>
          <td class="paramname"><em>state_variable_type</em> = <code>CartesianStateVariable::ALL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the distance between two CartesianStates </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>the first <a class="el" href="classstate__representation_1_1_cartesian_state.html" title="Class to represent a state in Cartesian space. ">CartesianState</a> </td></tr>
    <tr><td class="paramname">s2</td><td>the second <a class="el" href="classstate__representation_1_1_cartesian_state.html" title="Class to represent a state in Cartesian space. ">CartesianState</a> </td></tr>
    <tr><td class="paramname">state_variable_type</td><td>name of the state variable from the CartesianStateVariable structure to apply the distance on. Default ALL for full distance across all dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the two states </dd></dl>

</div>
</div>
<a id="a7902f9c04e14b09cea083fef52bab63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7902f9c04e14b09cea083fef52bab63d">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstate__representation_1_1_dual_quaternion_state.html">DualQuaternionState</a> state_representation::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_dual_quaternion_state.html">DualQuaternionState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the DualQuaternion to operate on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the exponential of the DualQuaternion provided </dd></dl>

</div>
</div>
<a id="aa4f74c47f1b651b4110cdcb5910eb967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f74c47f1b651b4110cdcb5910eb967">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstate__representation_1_1_dual_quaternion_state.html">DualQuaternionState</a> state_representation::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_dual_quaternion_pose.html">DualQuaternionPose</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the dual quaternion to calcualte the log on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the log of the dual quaternion </dd></dl>

</div>
</div>
<a id="afd5278dab9a7ce390edf9fff11629f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5278dab9a7ce390edf9fff11629f10">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstate__representation_1_1_dual_quaternion_state.html">DualQuaternionState</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_dual_quaternion_state.html">DualQuaternionState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the scalar to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_dual_quaternion_state.html" title="Class to represent a state in Dual Quaternion space. ">DualQuaternionState</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="ad0ecf01ef6c32f0774960cc594c3c3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ecf01ef6c32f0774960cc594c3c3ee">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_cartesian_wrench.html">CartesianWrench</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_cartesian_wrench.html">CartesianWrench</a> &amp;&#160;</td>
          <td class="paramname"><em>wrench</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the scalar to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_cartesian_wrench.html" title="Class to define wrench in cartesian space as 3D force and torque vectors. ">CartesianWrench</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="a576c45b2950c5ac7d9500fd6f6c59faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576c45b2950c5ac7d9500fd6f6c59faf">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> &amp;&#160;</td>
          <td class="paramname"><em>positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the scalar to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_joint_positions.html" title="Class to define a positions of the joints. ">JointPositions</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="a3767990e6f6c87c67ce7a7440c4ff2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3767990e6f6c87c67ce7a7440c4ff2df">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a> &amp;&#160;</td>
          <td class="paramname"><em>pose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the scalar to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_cartesian_pose.html" title="Class to define CartesianPose in cartesian space as 3D position and quaternion based orientation...">CartesianPose</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="a4e012e68f9c15706a30102f01ccfa057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e012e68f9c15706a30102f01ccfa057">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a> &amp;&#160;</td>
          <td class="paramname"><em>torques</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the scalar to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_joint_torques.html" title="Class to define torques of the joints. ">JointTorques</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="a92c6f4cfa69519364eb125984ede495d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c6f4cfa69519364eb125984ede495d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> &amp;&#160;</td>
          <td class="paramname"><em>positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the array to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_joint_positions.html" title="Class to define a positions of the joints. ">JointPositions</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="a9019045800d04022d1bade922e94e841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9019045800d04022d1bade922e94e841">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> &amp;&#160;</td>
          <td class="paramname"><em>positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the matrix to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_joint_positions.html" title="Class to define a positions of the joints. ">JointPositions</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="a1500017a20744b0795b8e7bcc54c6faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1500017a20744b0795b8e7bcc54c6faa">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a> &amp;&#160;</td>
          <td class="paramname"><em>torques</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the array to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_joint_torques.html" title="Class to define torques of the joints. ">JointTorques</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="a7568276bd5f56d86c48480aca1937980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7568276bd5f56d86c48480aca1937980">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a> &amp;&#160;</td>
          <td class="paramname"><em>torques</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the matrix to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_joint_torques.html" title="Class to define torques of the joints. ">JointTorques</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="a7388fc5de6943b1f02e8ada69101e814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7388fc5de6943b1f02e8ada69101e814">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> &amp;&#160;</td>
          <td class="paramname"><em>velocities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the scalar to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_joint_velocities.html" title="Class to define velocities of the joints. ">JointVelocities</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="a23a56e7a3754284d4646e18d07214cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a56e7a3754284d4646e18d07214cbe">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a> &amp;&#160;</td>
          <td class="paramname"><em>twist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the scalar to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_cartesian_twist.html" title="Class to define twist in cartesian space as 3D linear and angular velocity vectors. ">CartesianTwist</a> provided multiplied by lambda </dd></dl>

</div>
</div>
<a id="a237f512819d023e72fdd7e25823ac598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237f512819d023e72fdd7e25823ac598">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 6, 6 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a> &amp;&#160;</td>
          <td class="paramname"><em>twist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the matrix to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_cartesian_twist.html" title="Class to define twist in cartesian space as 3D linear and angular velocity vectors. ">CartesianTwist</a> provided multiplied by lambda </dd></dl>

</div>
</div>
<a id="a308e5f0c96d5ba3adf557042cc7260f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308e5f0c96d5ba3adf557042cc7260f6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[13/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> &amp;&#160;</td>
          <td class="paramname"><em>velocities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the array to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_joint_velocities.html" title="Class to define velocities of the joints. ">JointVelocities</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="abe3243044b171a3282f32bda0cfba683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3243044b171a3282f32bda0cfba683">&#9670;&nbsp;</a></span>operator*() <span class="overload">[14/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::nanoseconds &amp;&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a> &amp;&#160;</td>
          <td class="paramname"><em>twist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>the time period to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_cartesian_pose.html" title="Class to define CartesianPose in cartesian space as 3D position and quaternion based orientation...">CartesianPose</a> corresponding to the displacement over the time period </dd></dl>

</div>
</div>
<a id="a17eed679b5d1d20668d0e83683d0d114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17eed679b5d1d20668d0e83683d0d114">&#9670;&nbsp;</a></span>operator*() <span class="overload">[15/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> &amp;&#160;</td>
          <td class="paramname"><em>velocities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the matrix to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_joint_velocities.html" title="Class to define velocities of the joints. ">JointVelocities</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="aed7eda6bcdb34de72612278c643813e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7eda6bcdb34de72612278c643813e5">&#9670;&nbsp;</a></span>operator*() <span class="overload">[16/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::nanoseconds &amp;&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> &amp;&#160;</td>
          <td class="paramname"><em>velocities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>the time period to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_joint_positions.html" title="Class to define a positions of the joints. ">JointPositions</a> corresponding to the displacement over the time period </dd></dl>

</div>
</div>
<a id="ae488033c3315bd3004118c826743d9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae488033c3315bd3004118c826743d9b7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[17/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the scalar to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_joint_state.html" title="Class to define a state in joint space. ">JointState</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="a74f0ee08214ae0f7f1354b0f6e858767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f0ee08214ae0f7f1354b0f6e858767">&#9670;&nbsp;</a></span>operator*() <span class="overload">[18/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_jacobian.html">Jacobian</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a> &amp;&#160;</td>
          <td class="paramname"><em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_jacobian.html">Jacobian</a> &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pose</td><td>the <a class="el" href="classstate__representation_1_1_cartesian_pose.html" title="Class to define CartesianPose in cartesian space as 3D position and quaternion based orientation...">CartesianPose</a> to multiply with </td></tr>
    <tr><td class="paramname">jacobian</td><td>the <a class="el" href="classstate__representation_1_1_jacobian.html" title="Class to define a robot Jacobian matrix. ">Jacobian</a> to be multiplied with the <a class="el" href="classstate__representation_1_1_cartesian_pose.html" title="Class to define CartesianPose in cartesian space as 3D position and quaternion based orientation...">CartesianPose</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_jacobian.html" title="Class to define a robot Jacobian matrix. ">Jacobian</a> expressed in the new reference frame </dd></dl>

</div>
</div>
<a id="a9df08c49ebb7a5b7fd6045b160fdcb00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df08c49ebb7a5b7fd6045b160fdcb00">&#9670;&nbsp;</a></span>operator*() <span class="overload">[19/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the matrix to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_joint_state.html" title="Class to define a state in joint space. ">JointState</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="a940ca9b0d08c680b266ff48e33c48754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940ca9b0d08c680b266ff48e33c48754">&#9670;&nbsp;</a></span>operator*() <span class="overload">[20/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayXd &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the gain array to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_joint_state.html" title="Class to define a state in joint space. ">JointState</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="a4d1aa2faa1692a0c73ce73b8bada8550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1aa2faa1692a0c73ce73b8bada8550">&#9670;&nbsp;</a></span>operator*() <span class="overload">[21/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_jacobian.html">Jacobian</a> &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the matrix to multiply with </td></tr>
    <tr><td class="paramname">jacobian</td><td>the jacobian matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matrix multiplied by the jacobian matrix </dd></dl>

</div>
</div>
<a id="a5a9a517c3521af7a5d3439305d6756f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9a517c3521af7a5d3439305d6756f7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[22/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> state_representation::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the scalar to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classstate__representation_1_1_cartesian_state.html" title="Class to represent a state in Cartesian space. ">CartesianState</a> provided multiply by lambda </dd></dl>

</div>
</div>
<a id="a8ffbc4ed7807b6fcc474407a74619acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ffbc4ed7807b6fcc474407a74619acc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_predicate.html">Predicate</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to happened the string representing the <a class="el" href="classstate__representation_1_1_state.html" title="Abstract class to represent a state. ">State</a> to </td></tr>
    <tr><td class="paramname">predicate</td><td>the <a class="el" href="classstate__representation_1_1_predicate.html" title="A predicate is a boolean parameter as in the logic formalism. ">Predicate</a> to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="adbcc249941dfc96910558ddbf8236b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcc249941dfc96910558ddbf8236b4c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to happend the string representing the <a class="el" href="classstate__representation_1_1_shape.html">Shape</a> to </td></tr>
    <tr><td class="paramname">shape</td><td>the <a class="el" href="classstate__representation_1_1_shape.html">Shape</a> to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="a21a18748c983b2f629f88399e1229a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a18748c983b2f629f88399e1229a41">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to append the string representing the <a class="el" href="classstate__representation_1_1_state.html" title="Abstract class to represent a state. ">State</a> to </td></tr>
    <tr><td class="paramname">state</td><td>the <a class="el" href="classstate__representation_1_1_state.html" title="Abstract class to represent a state. ">State</a> to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="a600552d3b0b2c2e6e1e36c13146d252b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600552d3b0b2c2e6e1e36c13146d252b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_dual_quaternion_twist.html">DualQuaternionTwist</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to happend the string representing the state to </td></tr>
    <tr><td class="paramname">state</td><td>the state to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="ac4ec8c9bc8ac5d07af242028030da487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ec8c9bc8ac5d07af242028030da487">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_dual_quaternion_state.html">DualQuaternionState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to happend the string representing the state to </td></tr>
    <tr><td class="paramname">state</td><td>the state to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="aac1763cbeb882101adea1eb25ca812bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1763cbeb882101adea1eb25ca812bf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_dual_quaternion_pose.html">DualQuaternionPose</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to happend the string representing the state to </td></tr>
    <tr><td class="paramname">state</td><td>the state to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="a453657a4ff8913f8dcf07727b57f8299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453657a4ff8913f8dcf07727b57f8299">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_cartesian_wrench.html">CartesianWrench</a> &amp;&#160;</td>
          <td class="paramname"><em>wrench</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to append the string representing the <a class="el" href="classstate__representation_1_1_cartesian_wrench.html" title="Class to define wrench in cartesian space as 3D force and torque vectors. ">CartesianWrench</a> to </td></tr>
    <tr><td class="paramname"><a class="el" href="classstate__representation_1_1_cartesian_wrench.html" title="Class to define wrench in cartesian space as 3D force and torque vectors. ">CartesianWrench</a></td><td>the <a class="el" href="classstate__representation_1_1_cartesian_wrench.html" title="Class to define wrench in cartesian space as 3D force and torque vectors. ">CartesianWrench</a> to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="a323b4cab976a7171e8b9c04763f3c3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323b4cab976a7171e8b9c04763f3c3fa">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a> &amp;&#160;</td>
          <td class="paramname"><em>pose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to append the string representing the <a class="el" href="classstate__representation_1_1_cartesian_pose.html" title="Class to define CartesianPose in cartesian space as 3D position and quaternion based orientation...">CartesianPose</a> to </td></tr>
    <tr><td class="paramname"><a class="el" href="classstate__representation_1_1_cartesian_pose.html" title="Class to define CartesianPose in cartesian space as 3D position and quaternion based orientation...">CartesianPose</a></td><td>the <a class="el" href="classstate__representation_1_1_cartesian_pose.html" title="Class to define CartesianPose in cartesian space as 3D position and quaternion based orientation...">CartesianPose</a> to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="ac1bf41b61d156b78b76c6a43ac1c2910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bf41b61d156b78b76c6a43ac1c2910">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> &amp;&#160;</td>
          <td class="paramname"><em>positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to append the string representing the state </td></tr>
    <tr><td class="paramname">positions</td><td>the state to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="a33a1f1c5f2450f68282a298f835d6dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a1f1c5f2450f68282a298f835d6dab">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_torques.html">JointTorques</a> &amp;&#160;</td>
          <td class="paramname"><em>torques</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to append the string representing the state </td></tr>
    <tr><td class="paramname">state</td><td>the state to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="ab02014f17b7fbfa1c6190a13fb242073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02014f17b7fbfa1c6190a13fb242073">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> &amp;&#160;</td>
          <td class="paramname"><em>velocities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to append the string representing the state </td></tr>
    <tr><td class="paramname">state</td><td>the state to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="a7e3d53ca08f32ae9fa382b1f8602e300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3d53ca08f32ae9fa382b1f8602e300">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a> &amp;&#160;</td>
          <td class="paramname"><em>twist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to append the string representing the <a class="el" href="classstate__representation_1_1_cartesian_twist.html" title="Class to define twist in cartesian space as 3D linear and angular velocity vectors. ">CartesianTwist</a> to </td></tr>
    <tr><td class="paramname"><a class="el" href="classstate__representation_1_1_cartesian_twist.html" title="Class to define twist in cartesian space as 3D linear and angular velocity vectors. ">CartesianTwist</a></td><td>the <a class="el" href="classstate__representation_1_1_cartesian_twist.html" title="Class to define twist in cartesian space as 3D linear and angular velocity vectors. ">CartesianTwist</a> to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="a8d253fbc08f3cb1aba43c5295f6e234e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d253fbc08f3cb1aba43c5295f6e234e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_ellipsoid.html">Ellipsoid</a> &amp;&#160;</td>
          <td class="paramname"><em>ellipsoid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to happend the string representing the <a class="el" href="classstate__representation_1_1_ellipsoid.html">Ellipsoid</a> to </td></tr>
    <tr><td class="paramname">ellipsoid</td><td>the <a class="el" href="classstate__representation_1_1_ellipsoid.html">Ellipsoid</a> to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="aa9a259b5ad26441cd2b43a435761cc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a259b5ad26441cd2b43a435761cc51">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to append the string representing the state </td></tr>
    <tr><td class="paramname">state</td><td>the state to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="a9a51f5f098aa3fa2b8eec12a93e37694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a51f5f098aa3fa2b8eec12a93e37694">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_jacobian.html">Jacobian</a> &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to append the string representing the matrix to </td></tr>
    <tr><td class="paramname">jacobian</td><td>the <a class="el" href="classstate__representation_1_1_jacobian.html" title="Class to define a robot Jacobian matrix. ">Jacobian</a> to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="a7c4678bb5acdf070f0039eff1d8032fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4678bb5acdf070f0039eff1d8032fd">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; state_representation::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the ostream to append the string representing the state to </td></tr>
    <tr><td class="paramname">state</td><td>the state to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appended ostream </dd></dl>

</div>
</div>
<a id="a12f179ef6871fd79ae70b847651fdd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f179ef6871fd79ae70b847651fdd61">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void state_representation::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstate__representation_1_1_spatial_state.html">SpatialState</a> &amp;&#160;</td>
          <td class="paramname"><em>state1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstate__representation_1_1_spatial_state.html">SpatialState</a> &amp;&#160;</td>
          <td class="paramname"><em>state2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state1</td><td><a class="el" href="classstate__representation_1_1_spatial_state.html">SpatialState</a> to be swapped with 2 </td></tr>
    <tr><td class="paramname">state2</td><td><a class="el" href="classstate__representation_1_1_spatial_state.html">SpatialState</a> to be swapped with 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af345b0edaa0326532a3f5dce4072438a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af345b0edaa0326532a3f5dce4072438a">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void state_representation::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstate__representation_1_1_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstate__representation_1_1_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state1</td><td><a class="el" href="classstate__representation_1_1_state.html" title="Abstract class to represent a state. ">State</a> to be swapped with 2 </td></tr>
    <tr><td class="paramname">state2</td><td><a class="el" href="classstate__representation_1_1_state.html" title="Abstract class to represent a state. ">State</a> to be swapped with 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a832ff2cdc279aeecd369f8c1dc920a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832ff2cdc279aeecd369f8c1dc920a9a">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void state_representation::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstate__representation_1_1_jacobian.html">Jacobian</a> &amp;&#160;</td>
          <td class="paramname"><em>jacobian1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstate__representation_1_1_jacobian.html">Jacobian</a> &amp;&#160;</td>
          <td class="paramname"><em>jacobian2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jacobian1</td><td><a class="el" href="classstate__representation_1_1_jacobian.html" title="Class to define a robot Jacobian matrix. ">Jacobian</a> to be swapped with 2 </td></tr>
    <tr><td class="paramname">jacobian2</td><td><a class="el" href="classstate__representation_1_1_jacobian.html" title="Class to define a robot Jacobian matrix. ">Jacobian</a> to be swapped with 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb43830cd7d4bb607ab7aa93537c6df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb43830cd7d4bb607ab7aa93537c6df4">&#9670;&nbsp;</a></span>swap() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void state_representation::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;&#160;</td>
          <td class="paramname"><em>state1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstate__representation_1_1_joint_state.html">JointState</a> &amp;&#160;</td>
          <td class="paramname"><em>state2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state1</td><td><a class="el" href="classstate__representation_1_1_joint_state.html" title="Class to define a state in joint space. ">JointState</a> to be swapped with 2 </td></tr>
    <tr><td class="paramname">state2</td><td><a class="el" href="classstate__representation_1_1_joint_state.html" title="Class to define a state in joint space. ">JointState</a> to be swapped with 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b029559fdd5c2b0f67aeea8ce759a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b029559fdd5c2b0f67aeea8ce759a11">&#9670;&nbsp;</a></span>swap() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void state_representation::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> &amp;&#160;</td>
          <td class="paramname"><em>state1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> &amp;&#160;</td>
          <td class="paramname"><em>state2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state1</td><td><a class="el" href="classstate__representation_1_1_cartesian_state.html" title="Class to represent a state in Cartesian space. ">CartesianState</a> to be swapped with 2 </td></tr>
    <tr><td class="paramname">state2</td><td><a class="el" href="classstate__representation_1_1_cartesian_state.html" title="Class to represent a state in Cartesian space. ">CartesianState</a> to be swapped with 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
