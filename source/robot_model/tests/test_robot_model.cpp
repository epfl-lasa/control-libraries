#include "robot_model/Model.hpp"

#include <stdexcept>
#include <gtest/gtest.h>

#include "robot_model/Exceptions/InvalidJointStateSizeException.hpp"
#include "robot_model/Exceptions/FrameNotFoundException.hpp"

using namespace RobotModel;

class RobotModelTest : public testing::Test {
protected:
  void SetUp() override {
    robot_name = "franka";
    urdf = std::string(TEST_FIXTURES) + "panda_arm.urdf";
    franka = Model(robot_name, urdf);
    joint_state = StateRepresentation::JointState(robot_name, 7);
    set_test_configurations();
  }

  Model empty = Model();
  Model franka;
  std::string robot_name;
  std::string urdf;

  StateRepresentation::JointState joint_state;

  double tol = 1e-5;

  // Known test configurations generated by fixtures/generateRobotModelTestConfigurations.m
  std::vector<StateRepresentation::JointState> test_configs;
  std::vector<std::vector<double>> test_gravity_expects;
  std::vector<std::vector<double>> test_coriolis_expects;
  std::vector<std::vector<double>> test_inertia_expects;

  void set_test_configurations() {
    // Random test configuration 1:
    StateRepresentation::JointState config1("robot", 7);
    config1.set_positions({-2.620392, -1.572496, -2.777827, -1.026002, 0.571513, 0.412393, 1.716623});
    config1.set_velocities({0.235701, -0.859573, -0.861442, -0.727985, 0.577783, -0.815203, -0.524262});
    config1.set_accelerations({-0.512704, -0.790356, 0.716706, 0.396400, 0.467484, 0.301061, 0.032541});

    // Expected results for configuration 1:
    std::vector<double> gravity1 = {0.000000, 42.403751, 8.385425, 11.174609, 1.037264, -1.409007, 0.030247};
    std::vector<double> coriolis1 = {-1.157227, 1.025361, -0.330843, 0.121310, -0.016832, -0.225056, -0.005523};
    std::vector<double> inertia1 = {-0.451450, -1.131146, -0.300849, -0.291475, 0.007975, 0.028511, -0.008446};
    test_configs.push_back(config1);
    test_gravity_expects.push_back(gravity1);
    test_coriolis_expects.push_back(coriolis1);
    test_inertia_expects.push_back(inertia1);

    // Random test configuration 2:
    StateRepresentation::JointState config2("robot", 7);
    config2.set_positions({-1.006011, 0.570358, -2.216055, -2.628052, -2.782772, 3.617880, 2.725623});
    config2.set_velocities({-0.752279, -0.065180, 0.313388, -0.419629, 0.509073, 0.116236, -0.144415});
    config2.set_accelerations({-0.465612, 0.507472, 0.796753, 0.456888, -0.186340, 0.876632, -0.489145});

    // Expected results for configuration 2:
    std::vector<double> gravity2 = {0.000000, -0.710151, -7.641822, 13.320224, -0.781159, 1.066494, 0.035576};
    std::vector<double> coriolis2 = {0.094769, 0.016642, -0.048129, -0.039403, 0.011669, 0.028053, 0.000460};
    std::vector<double> inertia2 = {0.232165, 0.468344, 0.303575, 0.304581, 0.003182, 0.020870, -0.006630};
    test_configs.push_back(config2);
    test_gravity_expects.push_back(gravity2);
    test_coriolis_expects.push_back(coriolis2);
    test_inertia_expects.push_back(inertia2);

    // Random test configuration 3:
    StateRepresentation::JointState config3("robot", 7);
    config3.set_positions({0.192168, 1.603284, -1.345810, -2.321046, 2.478192, 0.241055, -1.162395});
    config3.set_velocities({0.183167, -0.593402, 0.271766, 0.596741, 0.003402, 0.301624, 0.591910});
    config3.set_accelerations({-0.533252, 0.201678, -0.775075, 0.031531, 0.675681, 0.841580, -0.003544});

    // Expected results for configuration 3:
    std::vector<double> gravity3 = {-0.000000, -23.696483, -22.561093, -2.000746, 1.601137, -0.443108, -0.062740};
    std::vector<double> coriolis3 = {0.571410, -0.328103, -0.369781, 0.066655, 0.038111, -0.074594, -0.003282};
    std::vector<double> inertia3 = {-0.963637, -0.089442, -0.746291, -0.328516, 0.086413, 0.082525, -0.006675};
    test_configs.push_back(config3);
    test_gravity_expects.push_back(gravity3);
    test_coriolis_expects.push_back(coriolis3);
    test_inertia_expects.push_back(inertia3);
  }
};

TEST_F(RobotModelTest, TestInitEmptyModel) {
  EXPECT_THROW(empty.init_model(), std::invalid_argument);
}

TEST_F(RobotModelTest, TestSetName) {
  empty.set_robot_name(robot_name);
  EXPECT_EQ(empty.get_robot_name(), robot_name);
}

TEST_F(RobotModelTest, TestSetUrdfPath) {
  empty.set_urdf_path(urdf);
  EXPECT_EQ(empty.get_urdf_path(), urdf);
}

TEST_F(RobotModelTest, TestInitModel) {
  empty.set_robot_name(robot_name);
  empty.set_urdf_path(urdf);
  EXPECT_NO_THROW(empty.init_model());
}

TEST_F(RobotModelTest, TestConstructor) {
  Model tmp(robot_name, urdf);
  EXPECT_NO_THROW(franka = tmp);
}

TEST_F(RobotModelTest, TestNumberOfJoints) {
  EXPECT_EQ(franka.get_number_of_joints(), 7);
}

TEST_F(RobotModelTest, TestForwardGeometryJointStateSize) {
  StateRepresentation::JointState dummy = StateRepresentation::JointState(robot_name, 6);
  EXPECT_THROW(franka.forward_geometry(dummy), Exceptions::InvalidJointStateSizeException);
}

TEST_F(RobotModelTest, TestForwardGeometry) {
  EXPECT_EQ(franka.forward_geometry(joint_state).get_position(),
            franka.forward_geometry(joint_state, "panda_link8").get_position());
}

TEST_F(RobotModelTest, TestForwardGeometryInvalidFrameName) {
  EXPECT_THROW(franka.forward_geometry(joint_state, "panda_link99"), Exceptions::FrameNotFoundException);
}

TEST_F(RobotModelTest, TestJacobianJointNames) {
  StateRepresentation::JointState dummy = StateRepresentation::JointState(robot_name, 7);
  StateRepresentation::Jacobian jac = franka.compute_jacobian(dummy);
  for (int i = 0; i < 7; ++i) {
    std::string jname = "panda_joint" + std::to_string(i + 1);
    EXPECT_TRUE(jname.compare(jac.get_joint_names()[i]) == 0);
  }
}

TEST_F(RobotModelTest, TestJacobianInvalidFrameName) {
  EXPECT_THROW(franka.compute_jacobian(joint_state, "panda_link99"), Exceptions::FrameNotFoundException);
}

TEST_F(RobotModelTest, TestJacobianNbRows) {
  StateRepresentation::Jacobian jac = franka.compute_jacobian(joint_state, "panda_joint2");
  EXPECT_EQ(jac.get_nb_rows(), 6);
}

TEST_F(RobotModelTest, TestJacobianNbCols) {
  StateRepresentation::Jacobian jac = franka.compute_jacobian(joint_state, "panda_joint2");
  EXPECT_EQ(jac.get_nb_cols(), joint_state.get_size());
}

TEST_F(RobotModelTest, TestComputeInertiaMatrix) {
  StateRepresentation::JointPositions jp = StateRepresentation::JointPositions::Random("robot", 7);
  Eigen::MatrixXd inertia = franka.compute_inertia_matrix(jp);
  EXPECT_TRUE(inertia.rows() == jp.get_size() && inertia.cols() == jp.get_size());
  // expect the matrix to be symmetric
  Eigen::MatrixXd upper_part = inertia.triangularView<Eigen::StrictlyUpper>();
  Eigen::MatrixXd lower_part = inertia.triangularView<Eigen::StrictlyLower>();
  EXPECT_TRUE(upper_part.isApprox(lower_part.transpose()));
}

TEST_F(RobotModelTest, TestComputeInertiaTorques) {
  StateRepresentation::JointState js = StateRepresentation::JointState::Random("robot", 7);
  StateRepresentation::JointTorques inertia_torques = franka.compute_inertia_torques(js);
  EXPECT_TRUE(inertia_torques.data().norm() > 0);

  for (std::size_t config = 0; config < test_configs.size(); ++config) {
    inertia_torques = franka.compute_inertia_torques(test_configs[config]);
    for (std::size_t joint = 0; joint < 7; ++joint) {
      EXPECT_NEAR(inertia_torques.get_torques()[joint], test_inertia_expects[config][joint], tol);
    }
  }
}

TEST_F(RobotModelTest, TestComputeCoriolisMatrix) {
  StateRepresentation::JointState js = StateRepresentation::JointState::Random("robot", 7);
  Eigen::MatrixXd coriolis = franka.compute_coriolis_matrix(js);
  EXPECT_TRUE(coriolis.rows() == js.get_size() && coriolis.cols() == js.get_size());
}

TEST_F(RobotModelTest, TestComputeCoriolisTorques) {
  StateRepresentation::JointState js = StateRepresentation::JointState::Random("robot", 7);
  StateRepresentation::JointTorques coriolis_torques = franka.compute_coriolis_torques(js);
  EXPECT_TRUE(coriolis_torques.data().norm() > 0);

  for (std::size_t config = 0; config < test_configs.size(); ++config) {
    coriolis_torques = franka.compute_coriolis_torques(test_configs[config]);
    for (std::size_t joint = 0; joint < 7; ++joint) {
      EXPECT_NEAR(coriolis_torques.get_torques()[joint], test_coriolis_expects[config][joint], tol);
    }
  }
}

TEST_F(RobotModelTest, TestComputeGravityTorques) {
  StateRepresentation::JointPositions jp = StateRepresentation::JointPositions::Random("robot", 7);
  StateRepresentation::JointTorques gravity_torques = franka.compute_gravity_torques(jp);
  EXPECT_TRUE(gravity_torques.data().norm() > 0);

  for (std::size_t config = 0; config < test_configs.size(); ++config) {
    gravity_torques = franka.compute_gravity_torques(test_configs[config]);
    for (std::size_t joint = 0; joint < 7; ++joint) {
      EXPECT_NEAR(gravity_torques.get_torques()[joint], test_gravity_expects[config][joint], tol);
    }
  }
}

TEST_F(RobotModelTest, TestGravityGetterAndSetters) {
  Eigen::Vector3d dummy_vector = Eigen::Vector3d::Random();
  EXPECT_FALSE((dummy_vector - franka.get_gravity_vector()).norm() < 1e-4);
  // set new gravity as dummy_vector and expect equality
  franka.set_gravity_vector(dummy_vector);
  EXPECT_TRUE((dummy_vector - franka.get_gravity_vector()).norm() < 1e-4);
}

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}