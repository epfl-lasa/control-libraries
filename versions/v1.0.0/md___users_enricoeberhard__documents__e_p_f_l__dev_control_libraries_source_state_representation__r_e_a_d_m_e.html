<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Control Libraries: state_representation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Control Libraries
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespacestate__representation.html">state_representation</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This library provides a set of classes to represent <b>states</b> in <b>Cartesian</b> or <b>joint</b> spaces, <b>parameters</b>, or <b>geometrical shapes</b> that can be used as obstacles. Those are a set of helpers functions to handle common concepts in robotics such as transformations between frames and the link between them and the robot state. This description covers most of the functionalities starting from the spatial transformations.</p>
<h2>Table of contents:</h2>
<ul>
<li><a href="#cartesian-state">Cartesian state</a><ul>
<li><a href="#cartesian-state-operations">Cartesian state operations</a></li>
<li><a href="#changing-of-reference-frame">Changing of reference frame</a></li>
<li><a href="#specific-state-variables">Specific state variables</a></li>
<li><a href="#conversion-between-cartesian-state-variables">Conversion between Cartesian state variables</a></li>
</ul>
</li>
<li><a href="#joint-state">Joint state</a><ul>
<li><a href="#joint-state-operations">Joint state operations</a></li>
<li><a href="#conversion-between-joint-state-variables">Conversion between joint state variables</a></li>
</ul>
</li>
<li><a href="#the-jacobian-matrix">The Jacobian matrix</a><ul>
<li><a href="#conversion-between-jointvelocities-and-cartesiantwist">Conversion between JointVelocities and CartesianTwist</a></li>
<li><a href="#conversion-between-jointtorques-and-cartesianwrench">Conversion between JointTorques and CartesianWrench</a></li>
<li><a href="#matrix-multiplication">Matrix multiplication</a></li>
<li><a href="#changing-the-jacobian-reference-frame">Changing the Jacobian reference frame</a></li>
</ul>
</li>
</ul>
<h2>Cartesian state</h2>
<p>A <code>CartesianState</code> represents the transformations between frames in space as well as their dynamic properties (velocities, accelerations and forces). It comprises the name of the frame it is associated to and is expressed in a reference frame (by default <code>world</code>). A state contains all the variables that define its dynamic properties, i.e <code>position</code>, <code>orientation</code>, <code>linear_velocity</code>, <code>angular_velocity</code>, <code>linear_acceleration</code>, <code>angular_acceleration</code>, <code>force</code> and <code>torque</code>. All those state variables use <code>Eigen::Vector3d</code> internally, except for the orientation that is <code>Eigen::Quaterniond</code> based. All getters and setters are implemented.</p>
<div class="fragment"><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> s1(<span class="stringliteral">&quot;a&quot;</span>); <span class="comment">// frame a expressed in world (default)</span></div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> s2(<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>); <span class="comment">// frame b expressed in a</span></div><div class="line"></div><div class="line">s1.set_position(Eigen::Vector3d(0, 1, 0)); <span class="comment">// 1 meter in y direction</span></div><div class="line">s1.set_orientation(Eigen::Quaterniond(0, 1, 0, 0));</div></div><!-- fragment --><p>By default, quaternions are normalized on setting, therefore:</p>
<div class="fragment"><div class="line"><span class="comment">// will be rendered as Eigen::Quaterniond(0.70710678, 0.70710678, 0. , 0.)</span></div><div class="line">s2.set_orientation(Eigen::Quaterniond(1, 1, 0, 0));</div></div><!-- fragment --><p>The state variables are also grouped in <code>pose</code> (<code>position</code> and <code>orientation</code>), <code>twist</code> (<code>linear_velocity</code> and <code>angular_velocity</code>), <code>accelerations</code> (<code>linear_acceleration</code> and <code>angular_acceleration</code>) and <code>wrench</code> (<code>force</code> and <code>torque</code>). Getter and setters are also implemented to do those bulk operations.</p>
<div class="fragment"><div class="line">s2.set_twist(Eigen::VectorXd::Random(6));</div></div><!-- fragment --><p>Note that for <code>pose</code>, it will be a <code>7d</code> vector (3 for <code>position</code> and 4 for <code>orientation</code>):</p>
<div class="fragment"><div class="line">s2.set_pose(Eigen::VectorXd::Random(7));</div></div><!-- fragment --><h3>Cartesian state operations</h3>
<p>Basic operations between frames such as addition, subtractions, scaling are defined, and applied on all the state variables. It is very important to note that those operations are only valid if both states are expressed in the same reference frame.</p>
<div class="fragment"><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> s1(<span class="stringliteral">&quot;a&quot;</span>); <span class="comment">// reference frame is world by default</span></div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> s2(<span class="stringliteral">&quot;b&quot;</span>);</div><div class="line"><span class="keywordtype">double</span> lamda = 0.5</div><div class="line"></div><div class="line"><span class="comment">// for those operation to be valid both s1 and s2</span></div><div class="line"><span class="comment">// should be expressed in the same reference frame</span></div><div class="line">state_representation::CartesianState ssum = s1 + s2;</div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> sdiff = s1 - s2;</div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> sscaled = lambda * s1;</div></div><!-- fragment --><p>Also, despite common mathematical interpretation, the <code>+</code> operator is <b>not commutative</b> due to the orientation part of the state. The addition <code>s1 + s2</code> corresponds to the transformation from the <code>world</code> frame to frame <code>a</code> followed by the transformation from <code>world</code> frame to frame <code>b</code>. If both frames have the same orientation then the <code>+</code> operator is commutative.</p>
<div class="fragment"><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> s1(<span class="stringliteral">&quot;a&quot;</span>);</div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> s2(<span class="stringliteral">&quot;b&quot;</span>);</div><div class="line">s1.set_orientation(Eigen::Quaterniond(0, 1, 0, 0));</div><div class="line">s2.set_orientation(Eigen::Quaterniond::UnitRandom());</div><div class="line"></div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> ssum1 = s1 + s2;</div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> ssum2 = s2 + s1;</div><div class="line"></div><div class="line">ssum1 != ssum2;</div></div><!-- fragment --><h3>Changing of reference frame</h3>
<p>One of the most useful operation is the multiplication between two states that corresponds to a changing of reference frame:</p>
<div class="fragment"><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> wSa(<span class="stringliteral">&quot;a&quot;</span>); <span class="comment">// reference frame is world by default</span></div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> aSb(<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// for this operation to be valid aSb should be expressed in a (wSa)</span></div><div class="line"><span class="comment">// the result is b expressed in world</span></div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> wSb = wSa * aSb;</div></div><!-- fragment --><p>Not only does that apply a changing of reference frame but it also express all the state variables of <code>aSb</code> in the desired reference frame (here <code>world</code>), taking into account the dynamic of the frame <code>wSa</code>, i.e. if <code>wSa</code> has a <code>twist</code> or <code>acceleration</code> it will affect the state variables of <code>wSb</code>.</p>
<h3>Specific state variables</h3>
<p>Full <code>CartesianState</code> can be difficult to handle as they contain all the dynamics of the frame when, sometime, you just want to express a <code>pose</code> without <code>twist</code>, <code>accelerations</code> or <code>wrench</code>. Therefore, extra classes representing only those specific state variables have been defined, <code>CartesianPose</code>, <code>CartesianTwist</code> and <code>CartesianWrench</code>. Effectively, they all extend from <code>CartesianState</code> hence they can be intertwined as will.</p>
<div class="fragment"><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_pose.html">state_representation::CartesianPose</a> wPa(<span class="stringliteral">&quot;a&quot;</span>);</div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> aSb(<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// the result is state b expressed in world</span></div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> wSa = wPa + aSb;</div></div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_pose.html">state_representation::CartesianPose</a> wPa(<span class="stringliteral">&quot;a&quot;</span>);</div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a> aVb(<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// the result is twist b expressed in world</span></div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a> wVa = wPa + aVb;</div></div><!-- fragment --><h3>Conversion between Cartesian state variables</h3>
<p>The distinction with those specific extra variables allows to define some extra conversion operations. Therefore, dividing a <code>CartesianPose</code> by a time (<code>std::chrono_literals</code>) returns a <code>CartesianTwist</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd_1_1chrono__literals.html">std::chrono_literals</a>;</div><div class="line"><span class="keyword">auto</span> period = 1h;</div><div class="line"></div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_pose.html">state_representation::CartesianPose</a> wPa(<span class="stringliteral">&quot;a&quot;</span>, Eigen::Vector3d(1, 0, 0));</div><div class="line"><span class="comment">// the result is a twist of 1m/h in x direction converted in m/s</span></div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a> wVa = wPa / period;</div></div><!-- fragment --><p>Conversely, multiplying a <code>CartesianTwist</code> (by default expressed internally in <code>m/s</code> and <code>rad/s</code>) to a <code>CartesianPose</code> is simply multiplying it by a time period:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd_1_1chrono__literals.html">std::chrono_literals</a>;</div><div class="line"><span class="keyword">auto</span> period = 10s;</div><div class="line"></div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a> wVa(<span class="stringliteral">&quot;a&quot;</span>, Eigen::Vector3d(1, 0, 0));</div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_pose.html">state_representation::CartesianPose</a> wPa = period * wVa; <span class="comment">// note that wVa * period is also implemented</span></div></div><!-- fragment --><h3>Cartesian state distance and norms</h3>
<p>As a <code>CartesianState</code> represents a spatial transformation, distance between states and norms computations have been implemented. The distance functions is represented as the sum of the distance over all the state variables:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestate__representation.html">state_representation</a>;</div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> cs1 = <a class="code" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">CartesianState::Random</a>(<span class="stringliteral">&quot;test&quot;</span>);</div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> cs2 = <a class="code" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">CartesianState::Random</a>(<span class="stringliteral">&quot;test&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> d = cs1.<a class="code" href="classstate__representation_1_1_cartesian_state.html#ad92a099fc98096c080dbc574f6b16230">dist</a>(cs2);</div><div class="line"><span class="comment">// alternatively one can use the friend type notation</span></div><div class="line">d = <a class="code" href="namespacestate__representation.html#a31f5461a6788ad4bae174490255b486f">dist</a>(cs1, cs2)</div></div><!-- fragment --><p>By default, the distance is computed over all the state variables. It is worth noting that it has no physical units, but is still relevant to check how far two states are in all their features. One can specify the state variable to consider using the <code>CartesianStateVariable</code> enumeration:</p>
<div class="fragment"><div class="line"><span class="comment">// only the distance in position</span></div><div class="line"><span class="keywordtype">double</span> d_pos = cs1.<a class="code" href="classstate__representation_1_1_cartesian_state.html#ad92a099fc98096c080dbc574f6b16230">dist</a>(cs2, CartesianStateVariable::POSITION);</div><div class="line"><span class="comment">// distance over the wrench</span></div><div class="line"><span class="keywordtype">double</span> d_wrench = cs1.<a class="code" href="classstate__representation_1_1_cartesian_state.html#ad92a099fc98096c080dbc574f6b16230">dist</a>(cs2, CartesianStateVariable::WRENCH);</div></div><!-- fragment --><p>When doing so, the unit of the distance is the one of the corresponding state variable. The norm of a state is using a similar API and returns the norms of each state variable:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestate__representation.html">state_representation</a>;</div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> cs = <a class="code" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">CartesianState::Random</a>(<span class="stringliteral">&quot;test&quot;</span>);</div><div class="line"><span class="comment">// default is norm over all the state variables, hence vector is of size 8</span></div><div class="line">std::vector&lt;double&gt; norms = cs.<a class="code" href="classstate__representation_1_1_cartesian_state.html#a4ef6fcae833ef73901d174b4a7e84b76">norms</a>();</div><div class="line"><span class="comment">// for only norm over the pose you need to specify it</span></div><div class="line">std::vector&lt;double&gt; pose_norms = cs.<a class="code" href="classstate__representation_1_1_cartesian_state.html#a4ef6fcae833ef73901d174b4a7e84b76">norms</a>(CartesianStateVariable::POSE);</div></div><!-- fragment --><p><code>normalize</code>, inplace normalization, and the copy normalization, <code>normalized</code>, are also implemented:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestate__representation.html">state_representation</a>;</div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> cs = <a class="code" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">CartesianState::Random</a>(<span class="stringliteral">&quot;test&quot;</span>);</div><div class="line"><span class="comment">// inplace, default is normalization over all the state variables</span></div><div class="line">cs.<a class="code" href="classstate__representation_1_1_cartesian_state.html#a4c066e4fdd6a5eda3579ce5ec8e80a01">normalize</a>()</div><div class="line"><span class="comment">// copied normalized state, with only linear velocity normalized</span></div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> csn = cs.<a class="code" href="classstate__representation_1_1_cartesian_state.html#a5bb2f9b6fd726f2c1d36d4a7dfbf0007">normalized</a>(CartesianStateVariable::LINEAR_VELOCITY)</div></div><!-- fragment --><h2>Joint state</h2>
<p><code>JointState</code> follows the same logic as <code>CartesianState</code> but for representing robot states. Similarly to the <code>CartesianState</code> the class <code>JointState</code>, <code>JointPositions</code>, <code>JointVelocities</code> and <code>JointTorques</code> have been developed. The API follows exactly the same logic with similar operations implemented.</p>
<p>A <code>JointState</code> is defined by the name of the corresponding robot and the name of each joints.</p>
<div class="fragment"><div class="line"><span class="comment">// create a state for myrobot with 3 joints</span></div><div class="line"><a class="code" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> js(<span class="stringliteral">&quot;myrobot&quot;</span>, std::vector&lt;string&gt;({<span class="stringliteral">&quot;joint0&quot;</span>, <span class="stringliteral">&quot;joint1&quot;</span>, <span class="stringliteral">&quot;joint2&quot;</span>}));</div></div><!-- fragment --><p>Note that if the joints of the robot are named <code>{"joint0", "joint1", ..., "jointN"}</code> as above, you can also use the constructor that takes the number of joints as input which will name them accordingly:</p>
<div class="fragment"><div class="line"><span class="comment">// create a state for myrobot with 3 joints named {&quot;joint0&quot;, &quot;joint1&quot;, &quot;joint3&quot;}</span></div><div class="line"><a class="code" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> js(<span class="stringliteral">&quot;myrobot&quot;</span>, 3);</div></div><!-- fragment --><p>All the getters and setters for the <code>positions</code>, <code>velocities</code>, <code>accelerations</code> and <code>torques</code> are defined for both <code>Eigen::VectorXd</code> and <code>std::vector&lt;double&gt;</code>:</p>
<div class="fragment"><div class="line">js.<a class="code" href="classstate__representation_1_1_joint_state.html#a1c25aa7209ea6e61d31a0e4a5f2d6af0">set_positions</a>(Eigen::Vector3d(.5, 1., 0.));</div><div class="line">js.<a class="code" href="classstate__representation_1_1_joint_state.html#a1c25aa7209ea6e61d31a0e4a5f2d6af0">set_positions</a>(std::vector&lt;double&gt;{.5, 1., 0.});</div></div><!-- fragment --><p>Note that when using those setters, the size of the input vector should correspond to the number of joints of the state:</p>
<div class="fragment"><div class="line">js.<a class="code" href="classstate__representation_1_1_joint_state.html#a1c25aa7209ea6e61d31a0e4a5f2d6af0">set_positions</a>(Eigen::Vector4d::Random()); <span class="comment">// will throw an IncompatibleSizeException</span></div></div><!-- fragment --><h3>Joint state operations</h3>
<p>Basic operations such as addition, subtraction and scaling have been implemented:</p>
<div class="fragment"><div class="line"><a class="code" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> js1(<span class="stringliteral">&quot;myrobot&quot;</span>, 3);</div><div class="line"><a class="code" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> js2(<span class="stringliteral">&quot;myrobot&quot;</span>, 3);</div><div class="line"><span class="keywordtype">double</span> lambda = 0.5;</div><div class="line"></div><div class="line"><span class="comment">// for those operation to be valid both js1 and js2</span></div><div class="line"><span class="comment">// should correspond to the same robot and have the</span></div><div class="line"><span class="comment">// same number of joints</span></div><div class="line"><a class="code" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> jssum = js1 + js2;</div><div class="line"><a class="code" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> jsdiff = js1 - js2;</div><div class="line"><a class="code" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> jsscaled = lambda * js1;</div></div><!-- fragment --><p>Multiplication of joint states doesn't have a physical meaning and is, therefore, not implemented.</p>
<h3>Conversion between joint state variables</h3>
<p>Similarly to <code>CartesianState</code>, the conversion between <code>JointPositions</code> and <code>JointVelocities</code> happens through operations with <code>std::chrono_literals</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd_1_1chrono__literals.html">std::chrono_literals</a>;</div><div class="line"><span class="keyword">auto</span> period = 1h;</div><div class="line"></div><div class="line"><span class="comment">// create a state for myrobot with 3 joints named {&quot;joint0&quot;, &quot;joint1&quot;, &quot;joint3&quot;}</span></div><div class="line"><span class="comment">// and provide the position values</span></div><div class="line"><a class="code" href="classstate__representation_1_1_joint_positions.html">state_representation::JointPositions</a> jp(<span class="stringliteral">&quot;myrobot&quot;</span>, Eigen::Vector3d(1, 0, 0));</div><div class="line"></div><div class="line"><span class="comment">// result are velocities of 1 rad/h for joint0 expressed in rad/s</span></div><div class="line"><a class="code" href="classstate__representation_1_1_joint_velocities.html">state_representation::JointVelocities</a> jv = jp / period;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd_1_1chrono__literals.html">std::chrono_literals</a>;</div><div class="line"><span class="keyword">auto</span> period = 10s;</div><div class="line"></div><div class="line"><span class="comment">// create a state for myrobot with 3 joints named {&quot;joint0&quot;, &quot;joint1&quot;, &quot;joint3&quot;}</span></div><div class="line"><span class="comment">// and provide the velocities values</span></div><div class="line"><a class="code" href="classstate__representation_1_1_joint_velocities.html">state_representation::JointVelocities</a> wVa(<span class="stringliteral">&quot;a&quot;</span>, Eigen::Vector3d(1, 0, 0));</div><div class="line"></div><div class="line"><a class="code" href="classstate__representation_1_1_joint_positions.html">state_representation::JointPositions</a> jp = period * jv; <span class="comment">// note that jv * period is also implemented</span></div></div><!-- fragment --><h2>The Jacobian matrix</h2>
<p>The <code>Jacobian</code> matrix of a robot ensures the conversion between both <code>CartesianState</code> and <code>JointState</code>. Similarly to the <code>JointState</code>, a <code>Jacobian</code> is associated to a robot and defined by the robot and the number of joints. As it is a mapping between joint and task spaces, as for the <code>CartesianState</code>, it is also defined by an associated frame name and a reference frame.</p>
<div class="fragment"><div class="line"><span class="comment">// create a jacobian for myrobot with 3 joints, associated to frame A and expressed in B</span></div><div class="line"><a class="code" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jac(<span class="stringliteral">&quot;myrobot&quot;</span>, std::vector&lt;string&gt;({<span class="stringliteral">&quot;joint0&quot;</span>, <span class="stringliteral">&quot;joint1&quot;</span>, <span class="stringliteral">&quot;joint2&quot;</span>}), <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>);</div></div><!-- fragment --><p>The API is the same as the <code>JointState</code>, hence the constructor can also accept the number of joints to initialize the joint names vector.</p>
<div class="fragment"><div class="line"><span class="comment">// create a jacobian for myrobot with 3 joints named {&quot;joint0&quot;, &quot;joint1&quot;, &quot;joint3&quot;}, associated to frame A and</span></div><div class="line"><span class="comment">// expressed in world (default value of the reference frame when not provided)</span></div><div class="line"><a class="code" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jac(<span class="stringliteral">&quot;myrobot&quot;</span>, 3, <span class="stringliteral">&quot;A&quot;</span>);</div></div><!-- fragment --><p>The <code>Jacobian</code> is simply a <code>6 x N</code> matrix where <code>N</code> is the number of joints. Therefore, the data can be set from an <code>Eigen::MatrixXd</code> of correct dimensions.</p>
<div class="fragment"><div class="line">jac.set_data(Eigen::MatrixXd::Random(6, 3)); <span class="comment">// throw an IncompatibleSizeException if the size is not correct</span></div></div><!-- fragment --><p>All the functionalities of the <code>Jacobian</code> have been implemented such as <code>transpose</code>, <code>inverse</code> or <code>pseudoinverse</code> functions.</p>
<div class="fragment"><div class="line"><a class="code" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jacT = jac.<a class="code" href="classstate__representation_1_1_jacobian.html#ab5024535fdb4cc64978564e6bd4dbf99">transpose</a>();</div><div class="line"><span class="comment">// will throw an error as a 6 x 3 matrix is not invertible</span></div><div class="line"><a class="code" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jacInv = jac.<a class="code" href="classstate__representation_1_1_jacobian.html#a672de7bc28c4e1e1648be76acf3981de">inverse</a>();</div><div class="line"><span class="comment">// compute the pseudoinverse without the need of being invertible</span></div><div class="line"><a class="code" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jacPinv = jac.<a class="code" href="classstate__representation_1_1_jacobian.html#a28c16c069390204e9b1dd52666862540">pseudoinverse</a>();</div></div><!-- fragment --><p>Those operations are very useful to convert <code>JointState</code> from <code>CartesianState</code> and vice versa.</p>
<h3>Conversion between JointVelocities and CartesianTwist</h3>
<p>The simplest conversion is to transform a <code>JointVelocities</code> into a <code>CartesiantTwist</code> by multiplication with the <code>Jacobian</code></p>
<div class="fragment"><div class="line"><a class="code" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jac(<span class="stringliteral">&quot;myrobot&quot;</span>, 3, <span class="stringliteral">&quot;eef_frame&quot;</span>, <span class="stringliteral">&quot;base_frame&quot;</span>);</div><div class="line"><a class="code" href="classstate__representation_1_1_joint_velocities.html">state_representation::JointVelocities</a> jv(<span class="stringliteral">&quot;myrobot&quot;</span>, 3);</div><div class="line"><span class="comment">// compute the twist of eef_frame in base_frame from the joint velocities</span></div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a> eef_twist = jac * jv;</div></div><!-- fragment --><p>The opposite transformation, from <code>CartesianTwist</code> to <code>JointVelocities</code> requires the multiplication with the <code>inverse</code> (or <code>pseudoinverse</code>).</p>
<div class="fragment"><div class="line"><a class="code" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jac(<span class="stringliteral">&quot;myrobot&quot;</span>, 3, <span class="stringliteral">&quot;eef&quot;</span>);</div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a> eef_twist(<span class="stringliteral">&quot;eef&quot;</span>)</div><div class="line"><a class="code" href="namespacestate__representation.html">state_representation</a>::JointVelocities jv = jac.pseudoinverse() * eef_twist;</div><div class="line"><span class="comment">// in case of non matching frame or reference frame throw an IncompatibleStatesException</span></div><div class="line"><a class="code" href="namespacestate__representation.html">state_representation</a>::CartesianTwist link2_twist(&quot;link2&quot;, &quot;link0&quot;)</div><div class="line"><a class="code" href="namespacestate__representation.html">state_representation</a>::JointVelocities jv = jac.pseudoinverse() * link2_twist;</div></div><!-- fragment --><p>Note that the <code>inverse</code> or <code>pseudoinverse</code> functions are computationally expensive and the <code>solve</code> function that relies on the solving of the system <code>Ax = b</code> using <code>Eigen</code> has been implemented.</p>
<div class="fragment"><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a> eef_twist(<span class="stringliteral">&quot;eef&quot;</span>)</div><div class="line"><span class="comment">// faster than doing jac.pseudoinverse() * eef_twist</span></div><div class="line"><a class="code" href="namespacestate__representation.html">state_representation</a>::JointVelocities jv = jac.solve(eef_twist);</div></div><!-- fragment --><h3>Conversion between JointTorques and CartesianWrench</h3>
<p>The other conversion that is implemented is the transformation from <code>CartesianWrench</code> to <code>JointTorques</code>, this one using the <code>transpose</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_wrench.html">state_representation::CartesianWrench</a> eef_wrench(<span class="stringliteral">&quot;eef&quot;</span>)</div><div class="line"><span class="comment">// faster than doing jac.pseudoinverse() * eef_twist</span></div><div class="line"><a class="code" href="namespacestate__representation.html">state_representation</a>::JointTorques jt = jac.transpose() * eef_wrench;</div></div><!-- fragment --><h3>Matrix multiplication</h3>
<p>The <code>Jacobian</code> object contains an underlying <code>Eigen::MatrixXd</code> which can be retrieved using the <code>Jacobian::data()</code> method. Direct multiplication of the <code>Jacobian</code> object with another <code>Eigen::MatrixXd</code> has also been implemented and returns the <code>Eigen::MatrixXd</code> product.</p>
<div class="fragment"><div class="line"><a class="code" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jac(<span class="stringliteral">&quot;myrobot&quot;</span>, 3, <span class="stringliteral">&quot;eef&quot;</span>, Eigen::MatrixXd::Random(6, 3));</div><div class="line"><span class="comment">// alternatively can use the Random static constructor</span></div><div class="line"><a class="code" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jac = <a class="code" href="classstate__representation_1_1_jacobian.html#af91b214006a9f88862c39a21dc92dd3d">state_representation::Jacobian::Random</a>(<span class="stringliteral">&quot;myrobot&quot;</span>, 3, <span class="stringliteral">&quot;eef&quot;</span>);</div><div class="line">Eigen::MatrixXd mat = jac.<a class="code" href="classstate__representation_1_1_jacobian.html#a1ab87a65ad942bb45154b2d2c0a86f90">data</a>();</div><div class="line">Eigen::MatrixXd res = jac * Eigen::MatrixXd(3, 4); <span class="comment">// equivalent to  jac.data() * Eigen::MatrixXd(3, 4);</span></div></div><!-- fragment --><h3>Changing the Jacobian reference frame</h3>
<p>As stated earlier, the <code>Jacobian</code> is expressed in a reference frame and can, therefore, use the operations with <code>CartesianPose</code> to be modified. It relies on the usage of the overloaded <code>operator*</code> or the <code>set_reference_frame</code> function for inplace modifications. It is equivalent to multiply each columns of the <code>Jacobian</code> by the <code>CartesianPose</code> on both the linear and angular part of the matrix. For this operation to be valid, the <code>CartesianPose</code> name has to match the current <code>Jacobian</code> reference frame.</p>
<div class="fragment"><div class="line"><a class="code" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jac = <a class="code" href="classstate__representation_1_1_jacobian.html#af91b214006a9f88862c39a21dc92dd3d">state_representation::Jacobian::Random</a>(<span class="stringliteral">&quot;myrobot&quot;</span>, 3, <span class="stringliteral">&quot;eef&quot;</span>, <span class="stringliteral">&quot;base_frame&quot;</span>);</div><div class="line"><a class="code" href="classstate__representation_1_1_cartesian_pose.html">state_representation::CartesianPose</a> pose = <a class="code" href="classstate__representation_1_1_cartesian_pose.html#aeb83b9e4a6e9fba8f8d7651696f1ec24">state_representation::CartesianPose::Random</a>(<span class="stringliteral">&quot;base_frame&quot;</span>, <span class="stringliteral">&quot;world&quot;</span>);</div><div class="line"><span class="comment">// the result is the Jacobian expressed in world</span></div><div class="line"><a class="code" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jac_in_world = pose * jac;</div><div class="line"><span class="comment">// alternatively, one case use the set_reference_frame function for inplace modifications</span></div><div class="line">jac.<a class="code" href="classstate__representation_1_1_jacobian.html#a50f66f98090d207add70ea997f9f12dc">set_reference_frame</a>(pose);</div><div class="line"><span class="comment">// in case of non matching operation throw an IncompatibleStatesExceptions</span></div><div class="line">jac.set_reference_frame(<a class="code" href="classstate__representation_1_1_cartesian_pose.html#aeb83b9e4a6e9fba8f8d7651696f1ec24">state_representation::CartesianPose::Random</a>(<span class="stringliteral">&quot;link0&quot;</span>, <span class="stringliteral">&quot;world&quot;</span>));</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
